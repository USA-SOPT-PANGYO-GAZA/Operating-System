## 개요

(프로세스가 어떻게 만들어지는가 - 누가 프로세스를 만드는가)

- 부모 프로세스가 자식 프로세스를 생성 (= 하나의 프로세스가 다른 프로세스를 생성)
    - 생성하는 방법 : 복제 생성
        
        (뒤에서 설명 ..)
        
        부모가 자식을 생성 → 부모가 하나, 자식은 여럿 : 프로세스의 계층도가 트리 형태로 형성
        
- 프로세스의 트리(계층 구조) 생성
- 프로세스가 실행이 되려면? 자원 필요 → 보통 운체에서 받음
- 자원의 공유
    - 부모와 자식이 모두 자원을 공유하는 경우
    - 일부를 공유하는 경우
    - 전혀 공유하지 않는 경우 (**원칙적**으로는 공유하지 않음, 별도의 프로세스이므로 경쟁하는 관계)
- 프로세스가 실행이 될 때
    - 부모와 자식이 공존하며 실행되는 경우
    - 자식이 종료(terminate)될 때까지 부모가 기다리는(wait = blocked) 경우

---

## 프로세스의 생성

✔️ 부모가 자식을 생성 

✔️ 어떻게 생성? 복제 생성 (프로세스의 생성은 크게 2단계를 거침)

1. 부모의 주소 공간 → (주소공간을)자식 프로세스가 그대로 **복사**, 운영체제에 있는 데이터도 복사
2. 복제 생성을 한 뒤에는, 그 공간에 **새로운** 프로그램을 올려서 새로운 일을 하도록 (서로 다른 일을 할 수 있도록)

<aside>
🔍 유닉스 예
- 복제 생성 : **fork()** 
fork() 시스템 콜이 새로운 프로세스를 생성 

- 새로운 프로그램을 올리는 것 : **exec()** 
fork() 이후로 이어져, exec() 시스템 콜을 통해서 새로운 프로그램을 메모리에 올림 
→ 만약, 자식 프로세스를 만들지 않고 바로 exec() 하면, 새로운 프로그램이 됨 (=새로운 인생을 삼)

</aside>

## 프로세스 종료

크게 두가지 경우 (자발적으로 프로세스가 종료되는 것, 비자발적으로 종료되는 것)

1️⃣ 자발적으로 종료 

exit() 시스템 콜을 통해 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌 

→ 자식이 부모에게 어떠한 데이터를 보냄 (output data)

→ 프로세스의 경우, 자식이 부모보다 먼저 종료가 되고 wait 시스템 콜을 통해서 자식이 종료될 때 데이터를 전달하게 됨 

2️⃣ 비자발적으로 종료 (abort = 강제종료)

크게 3가지 경우에 강제 종료가 됨 

1. 자원의 할당치를 넘어선 요구를 한 경우
2. 자식에게 할당된 테스크가 더 이상 필요하지 않은 경우 (부모가 자식 프로세스를 생성한 이유는 일을 시키기 위해서, 더이상 필요하지 않는다면? 강제 종료)
3. 부모가 종료되는 경우 (일반적으로는 자식이 먼저 종료)
    
    - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행하지 않도록 함
    
    - 단계적으로 종료 
    

---

복제 생성, 새로운 프로세스 덮어 씌우는 과정 ..

프로세스의 생성은 부모 프로세스가 자식 프로세스를 생성하는 것을 말함 

- 자원 공유
    
    🤔 공유? 
    
    자식 프로세스가 부모 프로세스의 코드 데이터, 스택을 그대로 복사 
    
    → 어떻게 보면, 메모리 낭비 (자식과 부모의 내용이 똑같다고 할 경우)
    
    → 그래서 일단, 최대한 공유할 수 있는 것은 공유 
    
    ✅ 내용이 달라질 때, (ex. 데이터의 변수의 값이 달라지거나, 함수 호출이 달라져서 스택의 내용이 달라질 때 .. 각자의 길을 갈 때) 부모의 공유하던 메모리 공간을 일부 자식이 copy 해서 갖게 되는 것 
    
    ⇒ copy-on-write (cow) 라고 부름 (= write가 발생했을 때, 그 때 copy 하겠다!!), 필요한 부분만 메모리에 올라감 
    

## 프로세스와 관련한 시스템 콜

### fork() - create a child

부모 프로세스를 복제 생성

 

어떻게 돌아가는가?

```c
int main() {
    int pid;
    pid = fork();
    
    if (pid == 0) 
        printf("나는 자식이야")
    else if (pid > 0) {
        printf("나는 부모야")
}
```

main()을 다시 처음부터 실행하는 것이 아니라, fork() 다음부터 자식 프로세스가 실행 

왜? 부모 프로세스의 context, program counter를 복제하므로 fork() 이후부터 실행된다는 것을 자식 프로세스가 알고 있음 

기존의 함수 호출과 비슷하지만, 문맥을 바탕으로 작동 

📌 자식과 부모를 **구분** 📌

→ 부모의 경우, fork()의 결과값이 양수

→ 자식의 경우, 결과값이 0

이렇게, 부모와 자식의 return value가 다르기 때문에 원본과 복제본을 구분할 수 있음 (= 다른 일을 하게 할 수 있음)

### exec() - overlay new image

이그젝 이그젝 ..

다른, 완전히 새로운 프로세스로 만들어주는 시스템 콜 (이전의 과정은 모두 잊고 완전히 새로운 프로세스를 실행 .. 새로운 함수의 main부터 실행) 

```c
int main() {
    int pid;
    pid = fork();

    if (pid == 0) {
        printf("나는 자식이야")
        execlp("이그젝 이그젝 나는 새로운 인생을 살거야 - 새로운 프로그램의 main()부터 go")
    } else if (pid > 0) {
        print("나는 부모야")
    }
}
```

위 프로그램의 구조?

: 부모 프로세스가 자식을 만든 다음에 자식은 printf를 출력하고 **새로운** 코드를 실행, 자식을 만들고 새로운 프로그램을 덮어 씌우는 것 

<aside>
🤔 **항상 자식을 만들고 새로운 것을 덮어 씌워야 하나?**
→ Nope
: fork() 없이 바로 exec()을 통해 새로운 프로그램으로 덮어 씌울 수 있으나, 그 이후의 코드는 실행되지 않음 (되돌아 올 수 없는 상황이 됨)

</aside>

### wait() - sleep until child is done

block로 보내는, 잠들게 만드는 것 (.. 자식 프로세스를 만들고 종료될때까지 기다림 ..)

**언제까지 block?** 

프로세스 A가 wait() 시스템 콜을 호출하면, 

✔️ 커널은 자식이 종료될 때까지 프로세스 A를 sleep (CPU를 얻지 못함)→ block 상태 

✔️ 자식 프로세스가 종료되면 커널은 프로세스 A를 깨움 → ready 상태 

```c
int main() {
    int pid;
    pid = fork();
    
    if (pid == 0) 
        printf("나는 자식이야")
    else if (pid > 0) {
        printf("나는 부모야")
      wait() // 자식 프로세스가 끝날 때까지 -> 경쟁하는 것이 아님 (기다리는 모델)
}
```

### exit() - frees all the resources, notify parent

프로세스를 종료시킬 때 호출(명시적으로 호출/프로그램이 알아서 코드의 마지막에 호출)하는 시스템 콜

✅ 자발적 종료 

- 마지막 statement 수행 후 exit() 시스템 콜을 통해 호출
- 프로그램에 명시적으로 넣어주지 않아도 main() 함수가 리턴되는 위치에 컴파일러가 넣어줌

✅ 비자발적 종료 (외부에서 종료 - 부모, 사람 ..)

- 부모 프로세스가 자식 프로세스를 **강제 종료**
    - 자식 프로세스가 한계치를 넘어선 자원 요청
    - 자식에게 할당된 테스크가 더 이상 필요하지 않음
- 키보드로 kill, break 등을 친 경우
- 부모가 종료하는 경우

> 이렇게 4가지가 프로세스를 생성, 실행, 종료 .. 와 관련된 시스템 콜
> 

---

## 프로세스 간 협력

**원칙적**으로 프로세스는 독립적 (서로 cpu를 얻기 위해 경쟁 - 서로 상부상조 x ... 원칙적으로)

**독립적 프로세스**

프로세스는 각자의 주소 공간을 갖고 수행되므로 **원칙적으로** 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함 

**협력 프로세스**

(경우에 따라서, 프로세스들이 협력을 해야 보다 효율적인 경우가 있음)

프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스 수행에 영향을 미칠 수 있음

**프로세스 간 협력 메커니즘 (IPC : Interprocess Communication)**

크게 두가지 방법이 존재

1. message passing
    
    프로세스 A가 프로세스 B에 메시지를 보내서 그 영향을 주고 받음 
    
    → 프로세스는 원래 독립적이고 자신의 주소 공간만 볼 수 있음
    
    → **커널을 통해서 메시지를 전달** (커널이 메신저 역할을 함)
    
2. shared memory
    
    주소 공간을 공유하는 것 
    
    서로 다른 프로세스 간에도 **일부 주소 공간을 공유**하게 하는 shared memory 메커니즘이 있음 
    
    ⚠️ thread ⚠️
    thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기 어렵지만,
    동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력 가능 
    

### Message Passing

프로세스 사이에 **공유 변수(shared variable)를 일체 사용하지 않고** 통신하는 시스템 

2가지 방법으로 구분 (상대 메시지를 받아 볼 프로세스의 이름을 명시하는지, 하지 않는지에 따라서) 

📌 둘 다 커널을 사용하는 것은 동일 📌

1. Direct Communication
    통신하려는 프로세스의 이름을 **명시적으로** 표시 ... Q에게 전달하겠다 .. → 커널을 통해서 
    
2. Indirect Commnunication 
    mailbox (or port)를 통해 메시지를 간접 전달 → 커널을 통해서 
    
    .. 경우에 따라서는 문어발 식으로 데이터를 전달 받기도 함 (꼭 Q가 아니어도 되므로) 
    

### Share Memory

원칙적으로 프로세스는 독자적인 공간을 갖고 있음 → 자기 주소 공간만 볼 수 있음

그럼에도 불구하고, 일부 주소 공간을 두 프로세스가 공유하는 것 

.. 마찬가지로 커널을 통해서 (커널이 한번 ok → 프로세스 둘이서 잘 작업 .. 두 프로세스는 신뢰할 수 있어야 함 )
