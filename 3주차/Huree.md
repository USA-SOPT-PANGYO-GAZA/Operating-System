# 3강. Process

Date: 2022/02/28
Status: 운영체제
URL: https://core.ewha.ac.kr/publicview/C0101020140318134023355997?vmode=f

# 3-1강. Process1

[💻 KOCW-OS-4: Process](https://hyojaedev.tistory.com/30?category=1153831)

---

## 프로세스

실행 중인 프로그램

- A program in execution
    
    단순히 디스크에 저장되어 있는 프로그램은 프로세스가 아님
    

---

## 프로세스의 문맥 Context

**프로세스가 현재 어떤 상태인지 나타내는 모든 것을 문맥**

프로그램이 `무엇을, 어떻게, 어디까지 수행해서 현재 어떤 상태인지` 나타내는 것을 문맥

ex. 나의 문맥 = 키, 몸무게, 하루에 밥은 얼마나 먹고, 지식은 얼마나 있는지 등

→ 과거부터 지금까지 살아오는 과정을 거치면서 현재의 내(문맥)가 되는 것처럼 프로세스도 같음

**`<문맥 종류>`**

### 1. CPU 수행 상태를 나타내는 하드웨어 문맥

프로세스는 CPU를 통해 매순간 명령어를 실행하는데, 현재 어디까지 실행했는지 알려면

→ Register가 현재 어떤 값을 가지고 있는가?

→ Program Counter Register가 어디를 가리키고 있는가?

like, 코드의 어느 부분까지 실행했는가?

- 프로세스 메모리에 어떤 내용을 담고 있는가? 함수를 호출했으면 stack에 쌓이겠지?
- 무슨 내용을 어디까지 쌓아놨나?
- 프로그램 실행되면서 변수가 바꼈으면 지금 변수는 얼마인가?

### 2. 프로세스의 주소 공간 (메모리와 관련)

→ 코드, 데이터, 스택에 어떤 내용이 들어있는가?

### 3. 프로세스 관련 커널 자료 구조

운영체제가 해당 프로세스를 어떻게 평가하고 있는지를 알아야 함

→ PCB (Process Control Block)

→ Kernel stack : 시스템 콜이 발생하면 커널의 함수가 호출되고, 스택에 정보를 쌓음

커널은 여러 프로세스들이 공유함 

커널이 누구의 부탁을 받고 실행하는지에 따라 별도의 스택을 갖고 있음

항상 프로세스의 문맥을 파악해서 해당 프로세스가 어디까지 실행했는지 파악해야 함

왜냐면 현대의 프로세스는 time sharing이니까.

다음 번의 CPU를 잡았을 때 바로 그 다음 명령을 실행할 수 있게 된다.

---

## 프로세스의 상태 Process State

프로세스는 상태가 변경되며 수행된다.

- 생성 상태 created
- 준비 상태 ready
- 실행 상태 running
- 대기 상태 blocked
- 보류 준비 상태 suspended ready
- 보류 대기 상태 suspended blocked
- 종료 상태 terminated

 

![스크린샷 2022-02-28 오전 8.48.09.png](3%E1%84%80%E1%85%A1%E1%86%BC%20Proce%2000dc8/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2022-02-28_%EC%98%A4%EC%A0%84_8.48.09.png)

| 상태 | 설명 | 기타 |
| --- | --- | --- |
| Running | CPU를 잡고 명령을 수행 중인 상태 | 주요 상태 |
| Ready | CPU를 기다리는 상태(메모리 등 다른 조건을 모두 만족하고) | 주요 상태 |
| Blocked | CPU를 줘도 당장 명령을 수행할 수 없는 상태 | 주요 상태 |
|  | 프로세스 자신이 요청한 이벤트가 즉시 만족되지 않아 이를 기다리는 상태
프로세스가 요청한 입출력이 즉시 만족되지 않아 기다리는 상태
ex. 디스크에서 파일을 읽어와야 하는 경우 | 주요 상태 |
| New | 프로세스가 생성 중인 상태 | 경우에 따라 해당 상태도 추가함 |
| Terminated | 수행이 끝난 상태 | 경우에 따라 해당 상태도 추가함 |
|  | 정리하는 작업이 남아 있기 때문에 상태에 포함하기도 한다. | 경우에 따라 해당 상태도 추가함 |
- 😊 ***좀 더 디테일한 설명***
    1. `생성 상태, Created` : 사용자가 요청한 작업이 커널에 등록되고 PCB가 만들어져 프로세스가 만들어진 다음 준비나 보류 상태로 되기 위해 잠시 거치는 상태
        - 운체는 프로세스 생성 후 메모리 공간을 검사해 충분한 공간이 있으면 메모리에 할당하면서 준비 상태로 바꿔주고, 그렇지 못할 경우 보류 준비 상태로 만든다.
        
        ---
        
    2. `준비 상태, Ready` : CPU를 할당받기 위해 기다리고 있는 상태
        - CPU만 주어지면 바로 실행할 준비가 되어 있는 상태
        - 다중 프로그래밍 시스템의 경우, 준비 상태의 여러 프로세스들은 메모리에 적재되어 있으며 CPU를 할당받기를 기다리고 있는데 이들을 위해 큐(또는 리스트)가 사용된다.
        - 준비 상태의 프로세스들은 **순서에 따라 CPU를 할당받으면 실행 상태가 되는데 이때 순서를 정하는 것**을 **CPU 스케줄링**이라고 부른다.
        
        ---
        
    3. `실행 상태, Running` : CPU를 할당받아 실행 중인 상태
        
        이때 **CPU를 할당하는 것을 디스패치(Dispatch)**라고 부른다.
        
        - 단일 CPU 시스템 → 오직 한 개의 프로세스만이 CPU를 사용 가능해서 한 프로세스만이 실행 상태에 있을 수 있다.
        - 실행 상태의 프로세스는 CPU스케줄링 정책에 의해 CPU를 뺏길 수 있으며 이 경우 준비 상태로 바뀌게 된다.
        - 시간 할당량이 소진되어 뺏기는 시간 종료도 인터럽트가 동원되어 처리된다.
        
        ---
        
    4. `대기 상태, Blocked` : 실행 상태가 입출력이 필요하게 되어 시스템 호출을 하면 입출력 처리의 종료를 기다리면서 대기 상태로 바뀌게 되고 CPU는 바로 준비 상태의 프로세스들 중에서 하나를 선택해 실행해 줄 것이다.
        - 입출력 처리 요청, 바로 확보될 수 없는 자원을 요청 시에 CPU를 양도하고 요청한 일이 완료되기를 기다리면서 대기하는 상태
        - 대기 상태의 프로세스 역시 이들의 관리를 위해 큐가 사용된다.
        
        ---
        
    5. `종료 상태, Terminated` : 프로세스가 종료될 때 아주 잠시 거치는 상태
        - 할당되었던 모든 자원들이 회수되고 PCB만 커널에 남아있는 상태
        - 운체가 시스템에 남겨져 있는 이 프로세스의 흔적을 최종 정리 후 PCB를 삭제하면 프로세스가 완전히 사라지게 된다.
        
    6. `보류 상태, Suspended` : 메모리가 부족하거나 다른 이유에 의해 시스템은 활성 상태의 프로세스로부터 메모리를 회수할 경우
    
    - ***준비, 실행, 대기 → 활성 상태 Active State***
        
        : 실행될 프로그램과 데이터 등을 위해 메모리 공간의 일정량을 부여받았음
        

---

## 프로세스 상태도

![스크린샷 2022-02-26 오후 11.39.38.png](3%E1%84%80%E1%85%A1%E1%86%BC%20Proce%2000dc8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-02-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.39.38.png)

1. 프로세스가 생성되면 new상태에서 ready 상태가 된다.
2. ready 상태에서 CPU를 얻으면 running 상태가 된다.
3. CPU 얻은 상태에서 내려놓는 경우
    - running → terminated : 본인의 역할을 다했으면 종료된다.
    - running → blocked(waiting) : `[ I/O ]` 입출력 같은 오래 걸리는 작업을 하면, CPU를 가지고 있어 봐야 명령이 불가능하기 때문에 waiting 상태가 된다.
    - running → ready : `[ Timer interrup ]` CPU는 시간을 나눠서 써야 하는데 할당된 시간이 끝난 경우에 ready 상태가 된다.
    
    ![스크린샷 2022-02-26 오후 11.42.39.png](3%E1%84%80%E1%85%A1%E1%86%BC%20Proce%2000dc8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-02-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.42.39.png)
    

### 예시

running 상태의 프로세스가 사용자로부터 키보드 입력을 받아서 결과를 보고 실행한다고 가정하면,

1. 키보드 입출력 큐에 줄을 서게 된다. [ running → *blocked* ]
2. 키보드 입력을 받으면 키보드의 device controller가 CPU에게 interrupt를 걸어서 알려준다.
    
    : CPU는 하던 일을 멈추고 운영체제에게 넘어가서 운영체제의 커널이 프로세스 상태를 변경
    
    [ → ready ] 
    

프로세스는 공유 데이터에 접근하던가, 디스크, 키보드 등 어떤 종류에 따라 그에 맞는 queue에 줄을 서게 된다.

like 놀이동산 줄서기

- ready 상태인 경우 CPU 주고, blocked인 경우 CPU 안준다.

---

## PCB, 프로세스 정보를 담고 있는 친구, 프로세스 제어 블록

***(Process Control Block)***

운영체제가 프로세스들을 관리하기 위해 **프로세스의 정보들을 담고 있다.**

- 테이블 모양의 자료구조
- “운영체제가 프로세스를 관리한다”
    
    = 해당 PCB에 대한 다양한 행동으로 이해되고, 
    
       PCB에 대한 작업은 매우 자주 일어나서 메모리에 저장한다.
    

***[ PCB를 구성하는 요소 ]***

1. OS가 프로세스를 관리하기 위해 사용하는 정보
    1. 프로세스 상태 (준비, 실행, 대기, 보류 등의 상태)
    2. 프로세스 아이디 (고유한 정수 번호, 다른 프로세스와 구별하기 위해 사용)
    3. CPU 우선순위 값 (스케줄링 할 때 사용되는 우선순위)
2. 프로세스 문맥을 나타내기 위한 CPU 수행 관련 하드웨어 값 - PC register, register 
3. 메모리 관련 - 코드, 데이터, 스택이 메모리 어디에 위치해 있는가
4. 파일 관련 - 프로세스가 사용하고 있는 파일들

---

## 문맥 교환 Context Switch

**CPU**를 `한 프로세스에서 다른 프로세스로` 넘겨주는 과정을 의미한다.

[ 과정 ]

1. CPU를 내어주는(뺏기는) 프로세스 상태의 문맥을 해당 프로세스의 PCB에 저장한다.
2. CPU를 새롭게 얻는 프로세스의 상태의 문맥을 해당 프로세스의 PCB에서 읽어온다.

`[ 헷갈리기 쉬움 ]`

**시스템 콜이나 인터럽트 발생 시에 반드시 문맥 교환이 일어나는 것이 아님**

![스크린샷 2022-02-28 오전 8.00.48.png](3%E1%84%80%E1%85%A1%E1%86%BC%20Proce%2000dc8/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2022-02-28_%EC%98%A4%EC%A0%84_8.00.48.png)

1. `[ 문맥교환 X ]` 
    
    사용프로세스a가 유저모드 → 커널모드 → 유저모드
    
    → CPU가 사용자 프로세스에서 운영체제로 넘어가는 것이기 때문에 위와 다름
    
2. `[ 문맥교환 O ]` 
    
    시스템 콜이나 인터럽트가 들어온 후에 운영체제가 CPU 제어권을 다른 프로세스에게 넘겨준 경우
    
    → A → B로 문맥교환이 일어나면 **캐시 메모리를 다 지워야 해서** 상당한 오버 헤드임
    

---

## 프로세스를 스케줄링하기 위한 큐

프로세스들은 `큐`들을 오가며 수행된다.

1. Job queue : 
    
    현재 시스템 내에 있는 모든 프로세스의 집합 (Ready, Device queue도 포함)
    
2. Ready queue : `[ CPU를 기다리는 큐 ]`
    
    현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
    
3. Device queue : 
    
    **입출력 장치**의 처리를 기다리는 프로세스의 집합
    

![스크린샷 2022-02-28 오전 8.09.19.png](3%E1%84%80%E1%85%A1%E1%86%BC%20Proce%2000dc8/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2022-02-28_%EC%98%A4%EC%A0%84_8.09.19.png)

PCB를 큐에 줄세운다.

하드 디스크의 서비스를 기다리는 프로세스가 쭉 줄 서 있음

이걸 운영체제가 관리함

![스크린샷 2022-02-28 오전 8.10.34.png](3%E1%84%80%E1%85%A1%E1%86%BC%20Proce%2000dc8/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2022-02-28_%EC%98%A4%EC%A0%84_8.10.34.png)

1. 프로그램이 시작되면 레디큐에 와서 줄 서게 됨
2. 자기 차례가 되면 CPU를 얻고
3. 얻은 상황에서 Timer가 다 되면 다시 레디큐에 와서 줄 서야 하고, 
4. CPU를 가지고 있다가 오래 걸리는 작업을 수행하면 해당하는 작업의 큐에 가서 줄 서 있어야 함
5. 다 끝나면 큐를 빠져 나가는 것

---

## 스케줄러

시스템 안에서 각가의 자원 별로 이번에 무엇을 하고, 다음에는 무엇을 하는지 알려줌

### 🔥 Short-term scheduler (단기 스케줄러, CPU scheduler)

어떤 프로세스에 `CPU`를 주는 문제

- 다음 번에 어떤 프로세스를 running 시킬지 결정한다.
- 충분히 빨라야 한다. (milli second 단위)

### Long-term scheduler (장기 스케줄러, job scheduler)

어떤 프로세스에 `memory`를 주는 문제

- 시작 프로세스(new 상태) 중 어떤 것을 ready queue로 보낼지 결정한다.
- 메모리에 올라가 있는 프로세스의 수를 제어한다.
- **time sharing system에는 보통 장기 스케줄러가 없다. (항상 ready)**
    
    → 무조건 ready 즉, 프로그램 100개를 실행하면 모두 ready 상태
    

### Medium-term scheduler (중기 스케줄러, Swapper)

프로세스에서 `memory를 뺏는` 문제 

- 메모리에 너무 많은 프로그램들이 올라가 있는 경우에
    
    여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아낸다.
    
- 메모리에 올라가 있는 프로세스의 수를 제어한다.

<aside>
✅ “지금의 시스템은 **장기 스케줄러가 없고**, **중기 스케줄러가 멀티프로그램의 degree 제어를 한다**.”

</aside>

<aside>
❓ **장기 스케줄러보다 중기 스케줄러가 더 효과적인 이유?**

- 메모리 여유가 없는데 지금 생성된 프로세스가 더 중요해서 반드시 메모리 줘야 하는 경우
- 메모리를 꽉 채우고 있는 프로세스들이 입출력 중이라 CPU는 쉬고 있을 가능성도 있음
    
    이때 새로운 프로세스에 CPU를 할당해 가동시키려면 메모리를 확보해야 하고 입출력 때문에 대기 중인 프로세스들 중 누군가를 보류시켜야 함
    
</aside>

### 🔥 보류 상태, 중기 스케줄러로 인해 프로세스의 상태 중에 추가된 상태

메모리를 빼앗긴 프로세스의 상태를 나타내기 위해서 `Suspended(stopped) 상태 = 보류 상태` 추가

1. ***`Swapping, 스와핑`***
    - Swapped Out : 메모리 공간 뺏기고 디스크로 나가는 것
    - Swapped In : 다시 메모리로 들어오는 것
2. `보류 준비 상태` : 생성된 프로세스가 바로 메모리를 받지 못하거나, **준비 또는 실행 상태에서(Ready, Running) 메모리를 잃게 될 때** 필요
    - 충분한 메모리 공간의 확보를 위해 준비 상태의 프로세스를 보류시킬 수 밖에 없을 경우,
    - 높은 우선순위의 보류 대기 상태 프로세스가 준비 상태가 되면서 실행 상태의 프로세스로부터 CPU를 뺏기게 되는 경우
3. `보류 대기 상태` : **대기 상태(Blocked)일 때 메모리 공간을 잃은 상태**
    - 바로 위의 대기를 보류 대기로 만드는 경우는, 그 당시 준비 상태의 프로세스가 있었다고 하더라도 메모리의 여유 공간을 더 확보하기 위해서 보류 대기가 되기도 한다.
    

***보류 상태의 필요성?*** 

→ 일차적으로 메모리 공간 확보

→ 실행되는 프로세스의 현재 결과가 바라던 것이 아닌 오류가 보일 때, 

→ 시스템에 위해를 가할 수 있는 수상한 행동을 보일 때, 

→ 주기적인 일이라서 다음 주기의 실행 때까지 메모리를 회수해도 문제되지 않을 때

| 상태 | 설명 | 기타 |
| --- | --- | --- |
| Running | CPU를 잡고 명령을 수행 중인 상태 | 주요 상태 |
| Ready | CPU를 기다리는 상태 | 주요 상태 |
| Blocked | CPU를 줘도 당장 명령을 수행할 수 없는 상태 | 주요 상태 |
|  | 프로세스 자신이 요청한 이벤트가 즉시 만족되지 않아 이를 기다리는 상태
ex. 디스크에서 파일을 읽어와야 하는 경우 | 주요 상태 |
| Suspended (stopped) | 외부적인 이유(=중기 스케줄러)로 프로세스의 수행이 정지된 상태
 | 주요 상태 |
|  | ex. 사용자가 프로그램 일시 정지시킨 상태 |  |
|  | ex. 시스템이 여러 이유로 프로세스 잠시 중단함 (너무 많은 프로세스가 메모리에 올라와 있을때) |  |
|  | 프로세스는 메모리에서 통째로 디스크로 swap out된다. | 주요 상태 |
| New | 프로세스가 생성 중인 상태 | 경우에 따라 해당 상태도 추가함 |
| Terminated | 수행이 끝난 상태 | 경우에 따라 해당 상태도 추가함 |
|  | 정리하는 작업이 남아 있기 때문에 상태에 포함하기도 한다. | 경우에 따라 해당 상태도 추가함 |
- `Blocked` : 자신이 요청한 이벤트가 만족되면 다시 Ready
- `Suspend` : 외부에서 재개해줘야 Active

![영상 다시 보기 ](3%E1%84%80%E1%85%A1%E1%86%BC%20Proce%2000dc8/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2022-02-28_%EC%98%A4%EC%A0%84_8.48.09.png)

영상 다시 보기 

![스크린샷 2022-02-28 오전 8.49.12.png](3%E1%84%80%E1%85%A1%E1%86%BC%20Proce%2000dc8/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2022-02-28_%EC%98%A4%EC%A0%84_8.49.12.png)

Suspended는 메모리를 아예 잃어버리는 것

---

## < 수업 초반 질문 >

- 동기식 입출력 : 프로세스가 운영체제를 통해서 입출력 요청을 함, 입출력을 수행하는 동안에 프로세스가 기다리면 입출력할 때까지 기다림
- 비동기식 입출력 : 수행하는 동안에 명령을 바로 실행함

---

## CPU 수행 단위, 스레드 Thread

`lightweight process` (가볍기 때문) ↔ heavyweight process

**프로세스 내부에 CPU 수행 단위가 여러 개 있는 것**을 스레드라고 부른다.

![스크린샷 2022-02-28 오후 1.05.52.png](3%E1%84%80%E1%85%A1%E1%86%BC%20Proce%2000dc8/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2022-02-28_%EC%98%A4%ED%9B%84_1.05.52.png)

- ***스레드랑 프로세스 일상 속 예시 설명***
    
    네이버 보면 한쪽 배너는 광고가 휙휙 바뀌고, 다른 쪽에서는 입력창 띄우고, 
    한쪽 배너에서 동영상이 자동 재생되고 등의 것들이 결국 네이버라는 메인 사이트를 구성하는 일인데 이것들이 결국 프로세스가 된다.
    
    이 작은 각각의 일들을 하나의 실행 단위로 세분화해서 관리하면 장점이 있는데
    
    우선, 여기서 네이버 메인 사이트라는 큰 틀은 프로세스고, 작은 하나하나의 일은 스레드다.
    

![스크린샷 2022-02-28 오전 9.30.03.png](3%E1%84%80%E1%85%A1%E1%86%BC%20Proce%2000dc8/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2022-02-28_%EC%98%A4%EC%A0%84_9.30.03.png)

프로세스마다 코드, 데이터, 스택으로 구성된 주소공간이 있고,

이 프로세스를 관리하기 위해 운영체제 내부에 PCB(프로세스의 정보를 담고 있는)가 있음

Program Counter가 메모리의 어느 부분을 실행하는지 가리키고 있음

같은 일을 하는 프로세스를 여러 개 띄워두고 싶은 경우,

프로세스는 하나만 띄워두고, CPU가 현재 어느 부분을 실행하는지 Program Counter만 여러개 두는 것

***즉, 프로세스 하나에 CPU 수행 단위를 여러대 두는 것 = 스레드***

**한 프로세스에 속한 각각의 스레드들은 프로세스가 가지는 주소 공간을 공유하면서** 

**Program Counter로 표현되는 현재의 실행 위치와 stack, register 값을 따로 갖게 된다.**

### Thread 구성

`<독립적으로 가지고 있는 것>` - CPU 수행과 관련

- program controller
- register set
- stack space

`<스레드가 공유하고 있는 것>` = task

- code section
- data section
- OS resources

### Multi-Threading 다중 스레딩

하나의 프로세스를 다수의 스레드로 만들어 실행하는 것

다중 스레딩을 하게 되면 하나의 프로세스 내에 다수의 실행 단위들이 존재하여 
**작업의 수행에 필요한 자원들을 공유하기 때문에 자원의 생성과 관리가 중복되는 것을 줄일 수 있다.**

- 그래서 만약, 한 스레드에 의해 메모리의 데이터가 변경된 경우, 다른 스레드들은 변경된 데이터를 사용하게 되며, 열린 파일은 다른 스레드들에게도 열린 상태로 사용된다.
- ex. Windows NT, Solaris, OS/2 등

### Thread 사용하면 좋은 점

`< CPU가 하나인 경우 >`

1. ***빠른 응답성 Responsiveness***
    
    : 하나 프로세스 안에 스레드 여러 개 두면, 하나의 스레드가 blocked 상태일 때 다른 스레드가 running 되어 처리 가능
    
    ex. 웹페이지 읽어올 때, 하나의 스레드가 - 그림을 불러오는 동안 / 다른 스레드가 - 텍스트 등을 보여주면 사용자는 결과 빨리 볼 수 있어서 답답함이 줄어든다.
    
2. ***자원 공유 Resource Sharing***
    
    : 같은 일을 하는 프로세스를 여러 개 띄워두면 메모리 낭비가 큼
    
    : 똑같은 일을 하는 프로그램을 하나의 프로세스로 만들고 n개의 스레드를 사용하면 자원을 공유하기 때문에 자원을 효율적으로 사용할 수 있다.
    
3. ***경제성 Economy***
    
    : 빠름
    
    : 문맥 교환은 오버헤드가 큰데(캐시메모리도 지워야 하고,, 등등), 
    
    스레드 간의 CPU 스위치는 동일한 주소공간을 사용하고 있기 때문에 **오버헤드가 크지 않음**
    

`< CPU가 여러개인 경우 >`

1. ***Utilization of MP(MultiProcessor) Architectures***
    
    : 서로 다른 CPU에서 **병렬적으로** 일해서 결과를 빠르게 얻을 수 있음
    

### 스레드 구현 방법

나중에 좀 더 알려주실 것이다!!!!!!!!!!!

- **커널 스레드** : `운영체제`에 의해 만드는 것
    
    → 스레드가 여러 개인 사실을 운영체제가 알고 있고, 
    
    → 하나의 스레드 → 다른 스레드로 CPU가 넘어가는 것도 커널이 넘겨줌
    
- **유저 스레드** : `라이브러리`에 의한 것
    
    → 운체는 스레드가 여러 개인 것을 모름
    
    → 구현 상의 제약점이 있음
    
- **realtime 스레드**

---

# 추가적인 면접질문

출처 : [https://github.com/4z7l/tech_interview.zip/blob/main/직무/OperatingSystem.md](https://github.com/4z7l/tech_interview.zip/blob/main/%EC%A7%81%EB%AC%B4/OperatingSystem.md)

1. **프로세스와 스레드의 차이는?**
    
    프로세스는 컴퓨터에서 실행 중인 프로그램을 말하고 고유한 공간과 자원을 할당 받아 사용한다.
    
    반면에, 스레드는 프로세스 안에서 실행되는 여러 흐름의 단위로 프로세스 내의 자원을 공유하고 고유한 stack만 각자 할당받는다.
    
2. **멀티 스레드 vs 멀티 프로세스**
    
    `멀티 스레드`는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 교환이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화(한 스레드에서 데이터 변경 시 다른 스레드도 변경된 데이터 사용한다는) 문제를 가지고 있다.
    
    반면, `멀티 프로세싱 방식`은 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 끼치지 않고, 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 있다. 
    
    이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합한지 부적합한지 구분된다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택해 적용해야 한다.
    
3. **멀티 프로세스 대신 멀티 스레드를 사용하는 이유?**
    - 프로그램을 여러 개 켜는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이 더 효율적이기 때문
    - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
    - 문맥 교환 시에 캐시 메모리를 비울 필요가 없어서 비용이 적게 들고 더 빠르다.
        
        → 스레드는 스택 영역만 초기화하면 되기 때문
        
    - 스레드는 프로세스 내의 메모리를 공유하기 때문에 데이터 전달이 간단하므로 비용이 적고 더 빠르다 → 프로세스의 스택 영역을 제외하고 모든 메모리를 공유하기 때문
    
4. **문맥 교환이란?**
    
    CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 것이다.
    
    여러 프로세스를 처리해야 하는 상황에서 현재 진행 중인 Task의 상태를 PCB에 저장하고 다음에 진행할 Task의 상태값을 읽어서 적용하는 과정을 말한다.
    
5. **문맥 교환의 과정?**
    1. Task의 대부분 정보는 Register에 저장되고 PCB로 관리된다.
    2. 현재 실행하고 있는 Task의 PCB 정보를 저장한다.
    3. 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행한다.
    
6. **프로세스 스케줄러의 종류?**
    - 장기 스케줄러 : 어떤 프로세스를 ready queue에 보낼지, 시분할 시스템에서는 잘 안씀
    - 단기 스케줄러 : 어떤 프로세스를 실행시킬지
    - 중기 스케줄러 : 메모리에 공간이 부족한 경우 어떤 프로세스를 swap out할지(메모리에서 뺄지)
    
7. **사용자 수준의 스레드와 커널 수준의 스레드 차이는?**
    - `커널 수준 스레드`
        - 스레드를 생성하고 스케줄링하는 주체가 커널
        - 장점 : 커널이 직접 제공해주므로 안정성과 다양한 기능 제공
        - 단점 : 유저 모드에서 커널 모드로의 전환이 빈번
    - `사용자 수준 스레드`
        - 스레드 기능을 제공하는 라이브러리를 이용하므로 커널에 의존하지 않음
        - 장점 : 커널이 스레드를 모르기 때문에 모드 간의 전환이 없고 성능 이득 발생
        - 단점 : 하나의 스레드가 커널에 블로킹되면서 프로세스 전체가 블로킹됨