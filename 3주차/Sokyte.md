## 프로세스 개념

- Process is **a program in execution (= 실행 중인 프로그램)**
- 프로세스의 **context** (문맥 → 어떠한 단어가 있다면, 여러 가지의 의미가 있지만 해당 단어가 정확하게 어떤 의미인지 알고 싶다면 문맥을 봐야하는 것처럼, 프로세스의 문맥도 마찬가지)
    
    → 특정 시점을 보았을 떄, 해당 프로세스가 어디까지 수행을 했는지를 규명하는데 필요한 것이 프로세스 문맥 
    
    ✔️ Program Counter가 어디를 가리키고 있는가 (= 코드의 어느부분까지 실행했는가)
    
    ✔️ 메모리에 어떤 내용을 어디까지 담고 있는가 
    
    ✔️ 과거의 프로그램들이 실행이 되면서, 현재의 시점까지 왔고 그 현재의 상태를 규명하기 위해서 필요 
    
    ✔️ 문맥은 크게 세가지로 설명할 수 있음 
    
    1. CPU 수행 상태를 나타내는 하드웨어 문맥 
        
        프로세스는 cpu를 잡고 매 순간 instruction을 실행 → 현재 시점에 프로세스가 instruction을 어디까지 실행했는가 .. (register .. pc를 통해서 알 수 있음)
        
        → Register가 어떤 값을 갖고 있는가 
        
    2. 프로세스의 주소 공간
        
        메모리와 관련
        
        현재 시점에 프로세스의 주소 공간, stack/data/stack에 어떤 내용이 들어가 있는가 
        
    3. 프로세스 관련 커널 자료 구조
        
        운영체제의 역할 중 하나인, 프로세스를 관리 → 프로세스가 생길 때마다 운체는 해당 프로세스를 관리하기 위해 PCB라는 자료구조를 두고 있음 → cpu, 메모리 .. 어떻게 관리하는지 .. 
        
        - PCB
        - Kernel stack (프로세스마다 별도로 두고 있음)
    
    ⇒ 즉, 문맥을 파악하기 위해서 `**cpu/메모리의 상태**`도 알아야 하고 이에 추가해서 운체가 해당 프로세스를 `**어떻게 평가**`하고 있는지도 알아야 함 
    
    .. 이러한 정보를 바탕으로 프로세스의 현재 상태를 알 수 있음 (프로세스가 혼자만 실행된다면, 알 필요가 없지만 컴퓨터의 경우 time sharing, multi-tasking .. 으로 여러개의 프로세스들이 번갈아 가면서 실행되므로, 실행된 정도를 알아야 함) 
    

## 프로세스 상태

프로세스의 상태(state)가 변경되며 수행

- 프로세스 상태도
    
    ## 프로세스 상태도
    
    - new : 프로세스가 생성 중인 상태
    - ready : 생성이 되어 cpu를 기다리는 상태 (실행 가능한 상태) → 최소한의 메모리 갖고 있는상태 (메모리에 올라온 상태)
    - running : 본인 차례가 되어서 cpu 얻게 된 상태
    - terminated : 할 일이 끝나서 cpu를 내어주는 상태
    - running → I/O or event wait → waiting(blocked) : I/O와 같은 오래 걸리는 작업을 해야 해서 cpu를 내어주는 경우
    - running → timer → ready : 프로세스 자체는 할 일이 남아 있는데 time sharing을 위해 할당 시간이 만료되어 줄 서있는 경우

(자원 중에는 하드웨어 자원도 있지만, `소프트웨어 자원`도 있음 - `‘공유 데이터’` : 여러 프로세스가 동시에 접근하게 되면, 일관성이 깨지는 문제 발생 → 하나의 프로세스가 해당 데이터에 접근하고 있다면, 다른 프로세스는 접근하지 못하도록 막아 주어야 함 → 이 때에도 데이터의 이용 차례를 관리하도록 Resource queue 필요) 

### Running

컴퓨터 안에 1개의 cpu가 하나가 있다고 할 때, cpu를 잡고 있는 프로세스는 매순간 1개 

cpu를 잡고 instruction을 `수행하고 있는 상태`

### Ready

cpu를 `기다리는 상태` 

→ cpu에서 실행이 되려면, 당장 필요한 부분은 물리적인 메모리에 올라와야 함 (디스크 접근을 못하기 때문에) 그러므로 ready 상태는 다른 조건은 모두 만족된 상태를 의미 

해당 상태의 프로세스들이 cpu를 잡았다가 놓았다가 하면서 time sharing 구현

### Blocked (wait, sleep)

cpu를 줘도 instruction 작업을 `하지 못하는 상태`

process 자신이 요청한 event가 즉시 만족되지 않아 이를 기다리는 상태 (ex. 디스크에서 파일을 읽어와야 하는 경우, 실행할 코드가 메모리에 올라와 있지 않은 경우) 

→ 위의 세가지는 프로세스가 “생성된” 이후의 상태를 말함 

경우에 따라서 두가지 상태가 추가되기도 함

**➕ New : 프로세스가 생성 중인 상태** 
이미 프로세스가 생성된 것이 아니라, 막 생성 중

 

**➕ Terminated : 수행(execution)이 끝난 상태** 
할 일(프로세스는 끝났지만)은 마쳤는데, 정리하는 작업이 있는 경우 

> 📌 **모든 자원이 놀지 않고 일을 할 수 있도록**
> 

→ 위와 같은 blocked .. runinng .. 의 정보를 커널 주소 공간의 Data 영역에서 관리

## Process Control Block (PCB)

운영체제(운체의 커널이) 각 프로세스를 관리하기 위해 프로세스 당 유지하는 정보

크게 4가지의 구성 요소를 갖고 있음 (구조체로)

1. OS가 관리상 사용하는 정보 (= 운영체제가 프로세스를 관리하기 위해 필요한 정보)
    - 프로세스의 상태 (ready ..)
    - 프로세스 id
    - scheduling information
    - priority
        
        (항상 라운드로빈 방식으로 처리하지 않기때문에) 
        
        → scheduling information, priority의 경우 프로세스에 cpu를 할당할 때 반드시, 먼저 온 순서대로 주는 것이 아님 
        
2. cpu 수행 관련 하드웨어 값 
    
    (= 프로세스의 문맥을 표시하기 위한 정보)
    
3. 메모리 관련
    
    (= 코드, 데이터, 스택이 어디에 위치해 있는가 와 관련된 정보)
    
4. 파일 관련

## 문맥 교환

- CPU는 빠른 자원이기 때문에 어떤 프로세스가 장악하여 계속해서 사용하는 것이 아니라, 얻었다가 뺏기는 과정을 반복
    
    → 다시 얻었을 때, 처음부터 시작하는 것이 아니라 뺏기던 시점의 문맥을 기억 후 다시 실행 
    
- CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행
    - CPU를 내어주는 프로세스의 상태를 해당 프로세스 PCB에 저장
    - CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 얻어옴

<aside>
📌 **문맥 교환 
→ system call 또는 interrupt 발생시 반드시 문맥 교환이 발생하는 것은 아님** 
(사용자 프로그램 → 운영체제로 넘어가는 것은 문맥 교환이 아님, 그러나 그 이후 다른 프로세스에게 넘겨주는 경우는 문맥 교환이라고 할 수 있음)

예시1)
사용자 프로세스A → (인터럽트 또는 시스템 콜) → 커널 → 사용자 프로세스 A
: 문맥 교환이라고 할 수 **없음** (문맥 교환 없이 user mode로 복귀)

예시2)
사용자 프로세스A → timer interrupt(cpu를 다른 프로세스에게 넘기기 위한 interrupt) 또는 입출력 요청 시스템 콜 → 커널 → 사용자 프로세스B 
: 문맥 교환이라고 할 수 **있음** 

1의 경우에도 CPU 수행 정보 등 문맥의 일부를 PCB에 저장하지만, 문맥 교환을 하는 2의 경우 부담이 더 크다. → 캐시 메모리를 지워야 하므로 (cache memory flush)

</aside>

## 스케줄러

순서를 정해주는 것 (자원별로)

### short-term scheduler (단기 스케줄러 or CPU scheduler)

짧은 시간 단위로 스케줄이 이루어짐 

- 다음번에 어떤 프로세스에게 CPU를 줄 지 (어떤 프로세스를 다음번에 running 시킬지 결정)
- 프로세스에 CPU를 주는 문제
- 충분히 빨라야 함 (millisecond 단위)

### long-term scheduler (장기 스케줄러 or job scheduler)

메모리를 어떤 프로세스에게 줄 지를 결정

- 프로세스가 시작이 될 때, new → ready로 넘어오는데 이 때, admitted .. 메모리에 올라가는 것을 의미, 프로세스가 메모리에 올라와야 비로소 ready 상태가 되어 CPU를 얻을 수 있음 ⇒ 메모리를 줄 지 말 지를 결정
- 프로세스에 메모리를 주는 문제
- degree of multiprogramming 을 제어 (메모리에 여러 프로그램이 올라가는 것) → 메모리에 프로그램이 몇개 올라가야 있는가를 나타내는 것, 메모리에 올라가는 프로세스의 수를 제어
    - 메모리에 너무 많은 프로그램이 올라가면 → 컴퓨터의 성능이 안좋아짐 (CPU를 잡고 프로그램을 실행하려고 봤더니, 너무 많은 프로그램이 있으므로 ..)
    - 메모리에 너무 적은 프로그램이 올라가면 → CPU가 하는 일이 없음

→ 실제로 해당 방식으로 작동하지 않음 (왜냐면, 지금의 프로그램들은 시작하면 메모리를 주긴 하기 때문에)

### medium-term scheduler (중기 스케줄러 or swapper)

swapper → 메모리에 너무 많은 프로그램이 동시에 많이 올라가 있다면, 일부 프로그램을 골라서 메모리에서 쫓아냄 
****
