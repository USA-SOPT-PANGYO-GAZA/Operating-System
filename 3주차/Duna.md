## **프로세스(Process)**

: 실행중인 프로그램(a program in execution)

- **프로세스의 문맥(context)**
    
    프로그램이 실행되는 중간 어느 시점을 봤을 때 **도대체 이 프로그램이 무엇을 어떻게 실행했는지, 현재 시점이 어떤 상태에 있는지**를 정확하게 나타내기 위해서 사용되는 개념
    
    특정 시점을 놓고 봤을 때, 도대체 이 프로세스가 **어디까지 수행을 했고 어디까지 와있는가를 규명**하기 위해서 필요한 요소가 **프로세스의 문맥**
    
    - **CPU 수행 상태를 나타내는 하드웨어 문맥**
        
        프로세스는 CPU를 잡고 매번 Instruction를 실행한다. 따라서 현재까지 프로세스가 Instruction를 어디까지 실행했는가를 알기 위해서는 Register에 어떤 값을 넣고 있었고 PC가 어디를 가르키고 있었고 이런 요소들이 필요하다.
        
        - Program Counter(PC) ← 코드의 어디까지 실행했는가
        - 각종 Register ← 현재 어떤 값을 가지고 있는가
        - 어떤 값을 넣어두고 어떤 Instruction까지 실행했는가
    - **프로세스의 주소 공간**
        
        현재 시점, 프로세스 메모리에 어떤 내용을 담고 있는가(= 무슨 내용을 어디까지 실행하고 있는가)
        
        - Data : 지금 변수의 값은 얼마인가
        - Stack : 현재 시점에 실행중인 함수는 어떤 것인지
        - Code : 어떤 코드를 실행중인지
    - **프로세스 관련 커널 자료 구조**
   
      ![스크린샷 2022-02-28 오후 3 02 07](https://user-images.githubusercontent.com/55099365/155932259-bbe4c4bf-0458-407b-bcbb-5eac5bc6d6ca.png)



        운영체제는 프로세스를 관리하기 위해서 자신의 데이터 영역에 PCB(Process Control Block)를 두고 있다.
        
        프로세스 하나가 실행될때마다 운영체제는 PCB를 하나씩 두고 있으면서 **이 친구한테 CPU를 얼마나 줘야할 지, 메모리를 얼마나 줘야할 지 관리하는 역할**
        
        ⇒ 운영체제가 PCB를 어떻게 평가하고 있는가를 보면 된다.
        
        프로세스가 실행되다가 자신이 할 수 없는 일이 생기면 운영체제를 호출한다.(System call) 이 상황에서는 PC가 커널 주소 공간 어딘가를 가르키게 되고 커널의 코드를 실행하게 된다. 커널도 함수들로 구성되기 때문에 함수 호출이 일어나면 스택에다가 관련된 정보들을 쌓아둔다. 
        
        커널은 여러 프로세스들이 공유하는 코드, 어떤 프로세스들 간에 운영체제에게 요청을 할 때 커널의 코드를 실행하게 되고 커널이 누구의 부탁을 받고 실행하는지가 매번 다르다. 커널에서 함수 호출이 일어나서 정보를 쌓을 때는 프로세스 별로 이 커널을 어떤 프로세스가 호출했는지에 따라서 스택을 별도로 두고 있다. 이렇게 해야지 정보가 꼬이는걸 막는다. 따라서 커널 스택을 프로세스마다 별도로 두고 있다. 
        
        ⇒ 본인의 Kernel Stack이 어떤 정보를 쌓고 있는지
        
    
    ▶️  현대의 컴퓨터 시스템에서는 Time-Sharing, Multi-tasking 등을 통해서 **프로세스들이 번갈아 가면서 실행이 되기 때문에 현재 프로세스가 진행되는 걸 백업해놓지 않으면(= 문맥을 알아놓지 않으면)** 다음번 CPU를 잡았을 때 앞 부분부터 다시 실행하는 문제가 생긴다. **문맥을 알아야 그 다음 시점부터 다시 실행이 가능해진다.** 
    

<br/>


## **프로세스의 상태(Process State)**

: 프로세스는 상태를 바꾸면서 실행을 한다.

![스크린샷 2022-02-28 오후 3 03 56](https://user-images.githubusercontent.com/55099365/155932434-8e0dc8f9-810f-49bd-bce9-ded5ad97ff4c.png)


✅  ***가정 : CPU가 하나밖에 없기 때문에 CPU를 잡고 있는 프로세스는 매 순간 하나이다.*** 

- **Running** : CPU를 잡고 Instruction를 수행중인 상태
- **Ready** : CPU를 기다리는 상태(메모리 등 다른 조건을 모두 만족하고)
    - **물리적 메모리에 올라가 있어서 CPU만 얻게 되면 당장 프로세스를 실행할 수 있는 상태**
    - Ready상태에 있는 프로세스들이 CPU를 번갈아 얻게 되면서 **Time-sharing를 구현**하고 있다.
- **Blocked(wait, sleep)** : CPU를 주어도 당장 Instruction을 수행할 수 없는 상태
    - **I/O 작업을 하는 상태** → 디스크에서 파일을 읽어와서야 Instruction를 실행할 수 있는 상태
    - 실행해야하는 코드가 메모리에 올라와있지 않고 **디스크에 내려가 있으면 당장 실행할 수 없는 상태**
    - 자신이 요청한 이벤트가 즉시 만족되지 않아서 이를 기다리는 상태
- **New** : 프로세스가 생성중인 상태
- **Terminated** : 수행이 끝난 상태 → 정리하는 작업을 실행중인 상태

▶️  **Running → Waiting(Blocked)** : I/O같은 오래걸리는 작업을 실행해야해서 CPU를 가지고 있어도 Instruction 실행이 불가능하다고 생각해서 CPU를 내려놓는 상태

▶️  **Running → Ready** : CPU를 계속 사용하고 싶은데 해당 프로세스에게 할당된 시간이 끝나서 CPU를 뺏긴 경우, 다시 Ready 상태로 돌아가서 자신의 차례가 오길 기다리는 상태

![스크린샷 2022-02-28 오후 3 04 31](https://user-images.githubusercontent.com/55099365/155932499-bd853e55-1d83-4789-9faf-3b65e9b5e88f.png)

**(하드웨어 자원) 1️⃣**  Ready queue → 2️⃣  실행할 순서가 되어서 CPU에서 Running → 3️⃣  중간에 I/O를 실행하게 되면 Blocked상태로 변경 Disk I/O queue에 줄을 선다 → 4️⃣  해당 프로세스가 원하는 I/O 작업이 끝나면 I/O Controller에서 CPU에 Interrupt를 건다 → 5️⃣  CPU는 실행중인 프로세스를 멈추고 CPU 제어권이 운영체제 커널로 넘어간다 → 6️⃣  운영체제는 프로세스 메모리 영역에 해당하는 데이터를 넘겨주거나 프로세스 상태를 Ready로 변경해주는 일을 진행한다 

**(소프트웨어 자원)** 공유 데이터를 여러 프로세스에서 동시에 접근하면 **접근을 하나씩 할 수 있도록 막아주는 작업**이 필요하다. ****프로세스는 **Blocked상태로 변경**되고 **Resource queue에서 자신의 차례를 기다리게 된다.**

✅  ***작업이 완료가 되면 Ready queue로 가서 CPU를 얻을 수 있게 된다.***

![스크린샷 2022-02-28 오후 3 05 21](https://user-images.githubusercontent.com/55099365/155932578-cdc46456-d82d-497f-8348-b9234f26e49e.png)

**운영체제 커널이 본인의 데이터 영역에 자료구조로 Queue를 만들어놓고 프로세스의 상태를 바꿔가면서 운영**

<br/>

## **Process Control Block(PCB)**

: 운영체제가 각 프로세스를 관리하기 위해 프로세스 당 유지하는 정보

![스크린샷 2022-02-28 오후 3 05 40](https://user-images.githubusercontent.com/55099365/155932623-2584b34d-a136-4ede-9251-51640ab9ec36.png)

▶️  **운영체제 커널이 프로세스를 관리하기 위해 자신의 데이터 영역에 두고 있는 PCB**

1. **OS가 관리상 사용하는 정보**
    - Process state : Ready, Running, Blocked 인지 확인하는 부분
    - Process ID : Process마다 숫자를 둬서 관리
    - Scheduling Information, Priority : 프로세스에게 CPU를 주기 위해서는 우선순위나 스케줄링 정보가 필요
2. **CPU 수행 관련 하드웨어 값**
    
    프로세스의 문맥을 표시하기 위한 정보
    
    - Program counter
    - Registers : CPU에다가 어떤 Register값들을 넣어서 실행하고 있었는지
3. **메모리 관련**
    - Code, data, Stack이 메모리 어디에 위치해 있는가에 대한 정보
4. **파일 관련**
    - 프로세스가 Open하고 있는 파일은 무엇이 있는지
    - 리소스 관련 정보
    
- **PCB에 저장되는 정보**
    - **프로세스 번호(PID)** : 프로세스의 고유한 정수 번호, 다른 프로세스와의 구별을 위해 사용
    - **프로세스의 상태(Status)** : 준비, 실행, 대기, 보류 등의 상태를 나타냄
    - **프로세스 우선순위(Priority)** : 스케줄링을 할 때 사용되는 우선순위
    - **프로세스 카운터 값(PC)** : 다음에 실행될 명령어의 주소 값
    - **메모리 포인터** : 프로그램과 데이터가 저장되어 있는 메모리 블록 위치와 공유되는 메모리 블록들에 대한 포인터를 포함
    - **문맥 데이터** : 문맥교환 시 CPU 레지스터 값들을 저장하는 영역
    - **할당받은 자원들에 대한 목록** : 개방한 파일 등 할당받은 자원들의 정보
    - 계정 정보 : CPU를 사용한 시간 등의 정보
    - 입출력 정보 : 진행 중인 입출력 요구 등의 정보

<br/>

## **문맥 교환(Context Switch)**

: CPU를 **한 프로세스에서 다른 프로세스로 넘겨주는 과정**

: CPU가 **사용자 프로세스 하나로부터 또 다른 사용자 프로세스로 넘어가는 과정**

✅  ***CPU를 뺏겼다가 다시 실행했을 때 처음부터 다시 실행하는 것이 아닌 실행하던 시점부터 다시 실행하는 메커니즘이 필요하다***

![스크린샷 2022-02-28 오후 3 06 09](https://user-images.githubusercontent.com/55099365/155932672-2e6a84ca-6d87-43b5-a79f-fe7e50877f82.png)

**System Call이나 Interrupt 발생시(CPU 제어권이 운영체제에게 넘어감)** 반드시 context switch가 일어나는 것은 아니다.

→ 사용자 프로세스 하나로부터 다른 사용자 프로세스로 넘어가는 과정을 Context Switch라고 함.

→ **운영체제가 CPU를 다른 사용자 프로세스에게 넘겨주는 경우 존재 = Context Switch**

▶️  Timer Interrupt나 I/O 요청 System Call이 있으면 Ready 상태에 있는 프로세스에게 CPU를 넘겨줌

![스크린샷 2022-02-28 오후 3 06 38](https://user-images.githubusercontent.com/55099365/155932723-af5dd6e8-4770-40d1-94c5-568bc02dbed6.png)

프로세스에서 실행을 하다가 커널을 실행하기 때문에 **전에 실행중이던 프로세스를 실행하기 위해선 약간의 문맥이 저장**되어야 한다. 하지만 프로세스 자체가 바뀌는 거에 비해서는 커널 모드로 들어왔다가 나가는게 **Overhead가 적다**. CPU Context정도만 세이브했다가 복원하면 된다.

eg. cache memory flush : **상당한 오버헤드**. A에서 B로 넘어가게 되면 사용하던 캐시 메모리를 모두 지워야 한다. User mode와 Kernel mode를 왔다갔다 하는 상태에서는 그렇게 하지 않아도 된다. 

- **Switching**
    - **Mode Switching : 인터럽트 처리 전후의 프로세스가 같은 경우**
    - **Process Switching : 인터럽트 처리 전후의 프로세스가 달라지는 경우**
    
    ▶️  **둘 다 문맥교환이 있지만 후자일 때 해주어야 할 일이 기술적으로 더 요구되기 때문에 프로세스 스위칭을 문맥교환이라 한다.**
   
<br/>

## **프로세스를 스케줄링하기 위한 큐**

- **Job queue** : 현재 시스템 내에 있는 모든 프로세스의 집합
    - Ready queue, Device queue에 있는 프로세스는 Job queue에 포함
- **Ready queue** : 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
- **Device queues** : I/O device의 처리를 기다리는 프로세스의 집합
- 
![스크린샷 2022-02-28 오후 3 07 01](https://user-images.githubusercontent.com/55099365/155932763-97036e59-2c6d-404d-b66e-5189c8f5b956.png)

- 운영체제가 프로세스를 관리하는 자료구조인 PCB를 줄세운다.
- Pointer가 있기 때문에 줄줄이 연결 가능

▶️  **프로세스들이 다양한 큐에 줄서서 서비스를 받게되고 운영체제가 이를 관리한다.**

![스크린샷 2022-02-28 오후 3 07 20](https://user-images.githubusercontent.com/55099365/155932811-354426b8-f223-4a81-a8b9-e4e6c3faa3ff.png)


- 프로그램 시작 → Ready queue → CPU를 얻음 → 할당 시간이 끝남 → Ready queue
- 프로그램 시작 → Ready queue → CPU를 얻음 → 오래걸리는 작업 실행 → 해당 작업 큐에 줄을 섬 → 해당 작업이 끝남 → Ready queue
- 프로그램 시작 → Ready queue → CPU를 얻음 → Interrupt가 걸림 → Ready queue(정확하게 Ready는 아님)
- 프로그램 시작 → Ready queue → CPU를 얻음 → 자식 프로세스를 만듦 → 자식 프로세스 실행 → Ready queue

<br/>

## **스케줄러(Scheduler)**

: 각각의 자원별로 이번에 무슨 일을 하고 시간을 얼만큼씩 잡고 이런걸 정하는게 스케줄러

- **Long-term scheduler(장기 스케줄러, job scheduler)**
    - 메모리를 어떤 프로세스에게 줄 지 결정(**new → ready 상태**에서 admitted해주는 것)
    - 시작 프로세스 중 어떤 것들을 ready queue로 보낼지 결정
    - ✅  **degree of Multiprogramming**(메모리에 여러 프로세스가 올라가는 것) 제어
        - **메모리에 올라가 있는 프로세스의 수를 제어 → 굉장히 중요한 이슈**
    - Time sharing system에는 보통 장기 스케줄러가 없음(무조건 ready)
        - **어떻게 degree of Multiprogramming를 제어하는가? Medium-term scheduler를 사용해서!**
        - 일단 메모리에 다 올려두고 너무 프로그램이 많이 올라가있다 싶으면 Medium-term scheduler가 몇 개를 쫓아냄
- **Short-term scheduler(단기 스케줄러, CPU scheduler)**
    - **아주 짧은 시간 단위로 스케줄이 이뤄짐** → 스케줄이 이뤄지는 단위가 millisecond 단위
    - 다음번에 어떤 프로세스한테 CPU를 줄 지 결정
- **Medium-term scheduler(중기 스케줄러, Swapper)**
    - 메모리에 너무 많은 프로세스들이 동시에 올라가 있으면 일부 프로그램을 골라서 메모리에서 통째로 쫓아낸다.
    - **degree of Multiprogramming을 제어**
    
<br/>

## 현대의 프로세스 상태

: **위의 프로세스 상태 + Suspended 상태**

![스크린샷 2022-02-28 오후 3 07 43](https://user-images.githubusercontent.com/55099365/155932852-773d5dc3-8d49-4a96-8edb-f46d3a310da3.png)

- 운영체제가 Running하는 것이 아니라 Kernel mode에서 Running하는 것
- Interrupt가 들어와도 여전히 Running하는 것으로 간주, 하지만 mode가 변경된다.
- 프로세스가 정지되어 있는 상태 = inactive
- Suspended상태에서도 Suspended Ready로 넘어갈 수는 있다.
- **추가**
    - Ready, Running, Blocked State의 Process를 모두 합치면 Multi-Programming Degree를 알 수 있다.
    - **Active State**는 어느 상태에 있든 **System으로 Memory를 부여받은 상태**다.
    - Ready 상태의 Process는 Queue, List를 통해서 관리된다.
    - Blocked 상태의 Process는 Queue, List를 통해서 관리된다.
    - 종료 상태는 프로세스가 종료될 때 아주 잠시 거치는 상태로 할당되었던 모든 자원들이 회수되고 PCB만 커널에 남아있는 상태다. 운영체제가 시스템에 남겨져 있는 프로세스의 흔적들을 최종 정리한 후에 PCB를 삭제하면 프로세스가 완전히 사라지게 된다.
    

- Suspended(stopped)
    
    CPU뿐만 아니라 해당 프로세스를 강제로 정지시켜둔 상태 → 메모리를 통째로 빼앗기 때문에
    
    - **프로세스를 통째로 디스크에 Swap out한 상태**
    - Suspended를 하는 경우
        - 메모리에 너무 많은 프로세스가 올라와 있을 때
        - 사용자가 프로그램을 일시 정지시킨 경우(break key) → 재개시켜줘야지만 다시 실행 가능
        - 실행되는 프로세스가 오류를 보일 때
    - (Swapped Out = Suspension / Swapped In = Resume) → Swapping
    
- **Suspended Ready, Blocked**
    - **보류 준비 상태** : 생성된 프로세스가 바로 메모리를 받지 못할 때나, 준비 또는 실행 상태에서 메모리를 잃게 될 때를 위해 필요
        
        → 메모리의 여유가 생기거나 준비 상태의 프로세스가 전혀 없을 때, 대기 상태의 프로세스를 보류 대기로 만들고 메모리 공간이 확보되면 준비 상태로 Resume (Swapping 발생)
        
    - **보류 대기 상태** : 대기 상태일 때 메모리 공간을 잃은 상태
        
        → 입출력이나 기다리던 사건의 종료 시 보류 준비 상태가 된다. 
        
- ✅  **Blocked와 Suspended의 차이**
    - **Blocked** : 자신이 요청한 이벤트를 하면서 오래 기다리고 있는 상태
        - 요청한 작업이 끝나면 다시 Ready상태로 돌아감
    - **Suspended** : 외부에서 정지시켜둔 상태
        - 외부에서 재개를 시켜줘야지만 Active상태로 돌아갈 수 있다.

<br/>

## Thread(Lightweight Process)

: **프로세스 내부의 CPU 수행 단위가 여러개 있는 경우**

: **프로세스 안에 CPU 수행 단위만 여러개를 두는 것**

![스크린샷 2022-02-28 오후 3 11 30](https://user-images.githubusercontent.com/55099365/155933232-a94aeb64-9277-477c-8b08-eb2c5bd725cc.png)

- 같은 일을 하는 프로세스마다 주소공간이 만들어져서 메모리가 낭비된다.
    - 같은 일을 하는 프로세스를 여러개 올리고 싶다면 **주소 공간 하나만 만들어두고 각 프로세스마다 다른 부분의 코드를 실행할 수 있게 해주면 된다**.
    
- **Thread의 구성(CPU 수행 부분)**
    
    ✅  **Thread마다 별도로 실행되어야 하는 부분**
    
    - Program Counter
    - Register set
    - Stack Space
- **Thread가 공유하는 부분(= task)**
    - Code Section
    - Data Section
    - OS Resources
    

▶️  프로세스는 하나기 때문에 **프로세스 상태, 프로세스 내부 자원들 Thread 간 공유** 

→ 별도로 가지는 건 **CPU 수행과 관련된 정보**(PC, Register, Stack)

▶️  **Thread 여러 개, Task 한 개**

![스크린샷 2022-02-28 오후 3 12 14](https://user-images.githubusercontent.com/55099365/155933283-f1e262b7-63d1-460c-90e0-8dcf0cf17606.png)

<br/>

## Thread의 장점

- **응답성**
    - 다중 스레드로 구성된 태스크 구조에서는 하나의 서버 스레드가 blocked(waiting)상태인 동안에도 동일한 태스크 내의 다른 스레드가 실행(Running)되어 빠른 처리를 할 수 있다.
        
        ex. 하나의 스레드가 웹 페이지의 이미지를 불러오는 동안에 해당 스레드를 blocked시키지 않고 또 다른 스레드가 이미 읽어온 텍스트라도 display해줌. 답답함이 덜하다. **빠른 응답성 제공**
        
- **자원 공유**
    - 동일한 일을 하는 프로그램들을 별도의 프로세스로 만들기 보다는 하나의 프로세스로 만들고 그 안에 CPU 수행 단위만 여러개를 두게 된다면 각종 자원은 Thread들이 공유하기 때문에 자원을 효율적으로 사용할 수 있게 된다.
    - 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율(throughput)과 성능 향상을 얻을 수 있다.
        - 자원을 절약 → 같은 일하는 프로세스를 여러개 만들어두면 별도의 코드, 데이터, 스택을 가지고 가기 때문에 메모리 낭비가 심하다.
        - 하나의 프로세스안에 Thread만 여러개 두게 된다면 **성능 향상, 자원 절약 효과**가 생김
    - 프로세스 내 스레드 간 통신은 메모리와 파일을 공유하기 때문에 커널의 개입이 필요없음
- **경제성**
    - **프로세스를 하나 만드는 건 오버헤드가 크지만 쓰레드를 하나 만드는건 오버 헤드가 크지 않다.**
    - 문맥 교환은 오버헤드가 크지만 쓰레드간의 CPU Switching은 동일한 공간을 사용하고 있기 때문에 대부분의 문맥은 그대로 사용하고 있어서 오버 헤드가 크지 않다.
        
        ex. Solaris 운영체제안에서는 각각의 Overhead가 30배, 5배나 된다. 
        
- **Multiprocessor 아키텍쳐의 활용**
    - **CPU가 여러개 있는 환경에서 Thread를 여러 개 뒀을 때 얻을 수 있는 장점**
    - 각각의 Thread가 서로 다른 CPU에서 **병렬적으로** 일을 할 수 있다. → 결과를 더 빨리 얻을 수 있음
    - 스레드를 사용하면 **병렬성을** 높일 수 있다.
        - 독립적인 연산을 할 때, 서로 다른 CPU에서 실행하고서 합쳐주면 결과가 더 빨리 나오게 된다.
        - 병렬적으로 실행되기 때문에 결과가 빨리 나온다.

- **스레드의 상태와 동기화**
    
    스레드 역시 실행, 준비, 대기와 같은 상태를 가짐
    
    - 보류는 프로세스 레벨의 개념이기때문에 스레드에서는 필요없는 상태 → **메모리는 프로세스 단위로 주어지는 시스템 자원이기 때문에(스레드는 메모리를 공유)**
    - 대기 : 레지스터 값, PC, 스택 포인터 등의 보관을 요구
    - 종료 : 해당 스레드의 레지스터 값들과 스택을 없앰
    - 스레드들이 프로세스의 주소 공간과 자원들을 공유하기 때문에 특정 스레드가 변경시킨 내용이 다른 스레드에 영향을 끼친다. → 스레드 실행의 동기화 요구

<br/>

## Thread를 구현할 수 있는 방법

- **운영체제 Kernel의 지원을 받는 Thread : Kernel Threads(= Kernel level Thread)**
    
    **Thread가 여러 개 있다는 사실을 운영체제가 알고 있음.**
    
    - 하나의 Thread에서 다른 Thread로 CPU가 넘어가는 걸 Kernel이 CPU 스케줄링하듯 넘겨준다.
    - 다중처리 환경일 경우 한 프로세스 내의 다수 스레드는 각각 처리기를 할당받아 **병렬 실행이 가능**
    - 한 스레드의 대기 시 **같은 프로세스에 속한 다른 스레드로 스위칭이 가능**
    - 같은 프로세스에 속한 스레드 간의 스위칭에도 **커널의 개입이 필요(모드 스위칭)**
    - 커널 레벨 스레드를 사용하게 된다면 스레드가 대기 중인 시간대에 다른 스레드를 실행할 수 있어서 중복된 만큼 전체 일의 종료 시간이 앞당겨진다.
    - **Example**
        - Windows 95/98/NT
        - Solaris
        - Digital UNIX, Mach
- **library 형태로 구현 : User Threads(= User level Thread)**
    
    **프로세스 안에 Thread가 여러개 있다는 사실을 운영체제가 모름.**
    
    - User 프로그램이 **라이브러리의 지원을 받아서 스스로 Thread를 관리**한다.
        - 스레드 라이브러리가 어디서부터 실행해야하는지 알려준다.
        - 스레드 간 스위칭은 라이브러리에 있는 스위칭 프로그램에 의해 결정되기 때문에 운영체제가 정한 스케줄링에 따를 필요가 없다. → **독자적인 스케줄링 사용 가능, 어떤 운영체제에서도 운영 가능**
    - 특정 스레드의 실행에서 대기는 자신이 소속된 프로세스의 대기를 초래한다.
        - 실행 중이었던 스레드는 스레드 라이브러리에 의해 실행으로 계속 간주되고 있다가 나중에 CPU가 다시 프로세스로 할당되었을 때 계속 실행해 나갈 수 있도록 해준다.
            
            ex. 스레드 실행 중, Time Interrupt가 날 경우 커널이 프로세스 Switching를 수행. 당시 실행 중이던 스레드 역시 실행 상태로 유지되다가 해당 프로세스가 CPU를 다시 받게 되면 다시 실행.
            
    - 커널이 볼 때는 일반적인 프로세스로 보이는데 **내부에서 CPU 수행단위를 여러개 둬서 관리** → 구현상의 제약은 존재
    - **단점**
        - 특정 스레드의 대기가 자신이 소속된 프로세스 내의 **모든 스레드들의 대기를 초래**
        - CPU가 프로세스 단위로 할당되기 때문에 **다중처리 환경이 주어진다해도 스레드 단위의 다중처리가 되지 못한다는 점 → 병렬적으로 실행 불가능**
    - **Example**
        - POSIX Pthreads
        - Mach C-threads
        - Solaris threads
- **Real-time threads**
    
    Real-time 기능을 하는 Thread
