## **하드웨어 구조**

<img width="1053" alt="스크린샷 2022-02-21 오전 7 31 45" src="https://user-images.githubusercontent.com/55099365/154936787-0dcd4f6d-387b-4072-99d5-b6a124e87a7a.png">


### **CPU + Memory로 구성된 컴퓨터와 I/O device들로 구성(간단)**

- memory : CPU의 작업 공간
    - CPU는 매순간, 매 Clock Cycle마다 메모리에서 기계어를 하나씩 읽어서 실행을 함.
- 키보드, 마우스 → 정보가 안으로 들어가는 device(Input Device)
- 프린트 → 처리 결과가 내보내는 device(Output Device)
- 하드 디스크(보조 기억 장치) → I/O device로 볼 수 있음
    - Disk에 있는 데이터를 읽어서 메모리로 읽어들이기도 하고(Input Device)
    - 처리 결과를 Disk에 저장하기도 한다(Output Device)


### **I/O device들은 그 Device를 전담하는 작은 CPU같은게 붙어있다 → device controller(hardware)**

- CPU와 I/O device들은 성능 속도 차이가 존재한다. 따라서, device controller가 각각의 I/O device들을 통제.
- ex. Disk의 head를 어떻게 움직일지, 어떤 데이터를 읽을지, 디스크 내부를 통제하는 건 CPU의 역할이 아니고 Disk Controller가 그 역할을 한다.
- CPU는 매 클락마다 Memory에서 Instruction를 읽어서 처리(반복)
- 제어 정보를 위해 control register, status register를 가진다.
    - buffer에 있는 값을 프로그램으로 넘겨주거나 프로그램에 있는 데이터를 화면에 출력하기 위해 buffer에 담은 다음에 어떻게 하라는 지시는 control register를 통해서 한다.
    - CPU : Memory, local buffer에 접근 / Device Controller : 자기 자신의 Local Buffer만 접근

▶️  device driver(sofeware) : OS 코드 중 각 장치별 처리루틴

- 하드웨어를 사용하기 위해서 디바이스 드라이버를 설치 해야한다.
- I/O device를 사용해야하는 상황이 오면 디바이스 드라이버를 사용해서 명령을 함.
- CPU가 I/O device를 실행하기 위해서 필요한 코드를 담고 있다.
- 일을 하기 위한 메뉴얼, 동작을 하기 위해서 무슨 일을 해야하는지 → 디바이스 내부에 **펌웨어**

 

### **Device Controller들의 작업 공간 → local buffer(data register)**

### **CPU안에는 Memory보다는 빠르면서 정보를 저장할 수 있는 작은 공간이 존재 → Register**

### **지금 CPU 안에서 실행되는 것이 운영체제인지, 사용자 프로그램인지 구분해주는 것 → Mode bit**

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 **보호 장치**
- 0 : 모니터 모드(커널 모드, 시스템 모드), OS 코드 수행
    - **이 때는 무슨 일이든 다 하게끔 되어 있다. ex. 메모리 접근, I/O 접근 가능(특권 명령)**
    - Interrupt가 들어오면 Mode bit를 0으로 바꾸고 CPU 제어권을 OS에게 넘겨줌
- 1 : 사용자 모드, 사용자 프로그램 수행
    - **제한된 Instruction만 실행 가능(보안상의 목적)**
    - 메모리 접근, I/O 접근 이런 시도를 하면 Mode bit를 보고 Instruction 실행이 안되도록 구현해둠.
    - OS가 mode bit를 1로 바꾸어서 넘겨줌
    - **I/O 어떻게 사용하는가?**
        
        운영체제에게 부탁한다.(System Call)
        사용자 프로그램이 운영체제의 커널 함수를 호출하는 것(직접 수행이 불가능하기 때문에)
        
        - 직접 OS로 주소 점프를 못하기 때문에(mode bit 1이기에) Interrupt line를 세팅하는 Instruction를 실행한다. → CPU가 Interrupt line를 확인하고 mode bit를 0으로 돌린 다음에 OS에서 I/O device controller에게 부탁
        - 올바른 요청인 경우에만 I/O를 수행

### **특정 프로그램이 CPU를 독점하는 것을 막는 것 → Timer**

- If, 계속 CPU를 쓰는 프로그램을 생성(무한 루프를 돔), 다른 프로그램에게 CPU가 넘어가지 못해서 Time Sharing를 사용할 수 없다. → 이런 상황을 위해서 Timer가 존재
- OS가 사용자 프로그램에게 CPU를 넘겨줄 때, 수십ms의 시간을 타이머에 세팅한 후에 넘겨준다.
- Instruction 실행 중간에 지정된 시간이 되면 Timer가 Interrupt를 건다.(타이머 Interrupt)
- OS가 사용자 프로그램에게 CPU를 줄 때는 자유롭게 주지만 한 번 넘어가면 뺏지 못함. 따라서, **Timer를 둬서 CPU가 사용자 프로그램에서 OS로 넘어올 수 있도록 만든 것.**
- OS가 관리를 하면서 타이머의 도움을 받아서 실행.
- CPU의 Time Sharing를 구현하기 위해서 Timer를 두고 있는 것 → 사용자 프로그램이 CPU를 사용하고 싶을 때 이야기
- I/O를 해야한다면 사용자 프로그램이 I/O를 해달라고 운영체제에게 자진해서 CPU를 넘기게 된다.
    - I/O device로의 접근은 OS를 통해서만 할 수 있도록 막아뒀다. → I/O 작업을 해야 할 때, 스스로 CPU를 넘겨주는 이유
    - I/O 작업 자체가 오래걸리다보니 해당 프로그램말고 다른 프로그램에게 CPU를 넘긴다.
    - I/O 작업을 요청한 프로그램은 I/O Controller가 요청한 작업이 끝나서 local buffer 해당 작업물을 저장하면 CPU에게 Interrupt를 건다. → 자동으로 CPU가 OS에게 넘어감
    - OS는 해당 buffer값을 해당 프로그램의 메모리 영역으로 copy해주고 Interrupt 당하기 전에 실행하던 프로그램을 실행(PC값에 저장된 주소값에 해당하는 프로그램) → Timer가 남아있다고 한다면, 아니면 I/O 작업을 요청한 프로그램에게 CPU를 준다.

### **CPU가 인터럽트가 발생했는지 감지하는 곳 → Interrupt line**

- **Interrupt : CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것
→ 각 자원(하드웨어 자원, Device, Peripherals)들의 현 상황을 파악할 수 있는 방식**
    1. I/O device가 작업을 처리하기 위해서 걸 수도 있고(Hardware interrupt)
    2. Timer가 시간이 끝나서 걸 수도 있고(Hardware interrupt)
    3. 사용자 프로그램이 I/O device를 사용하기 위해서 걸 수도 있다.(sofeware interrupt, **trap**)
        - System Call : 프로그램이 커널 함수를 호출(커널 모드 진행을 위해)
        - Exception : 프로그램이 오류를 범함(스스로 자신에게 인터럽트를 하는 경우)
- CPU가 Instruction를 처리하고 있는 중간에, I/O device일을 접근하는 Instruction를 처리하는 상황이 오는데  CPU는 Memory랑만 일하기 때문에 Memory를 접근하는 Instruction만 실행하게 되어 있다. 그러다가 디스크에서 읽어올 것이 있으면 요청을 보내는데 device controller에게 CPU가 일을 직접 시킨다.
- device controller는 진행한 일을 자신의 local buffer에 저장. **Input device에서 뭐가 들어오는지 지켜보는게 아니고 들어오면 알려달라고 한 뒤, 자신의 일을 계속한다(**이 행동 자체가 시간이 오래걸리기 때문)
- **“Input device에서 들어오는 값을 사용하지 않으면 더 이상 진행이 안된다”** 라고 한다면 CPU가 다른 프로그램에게 넘어간다.
- 하나의 Instruction이 끝나고 나면 Interrupt line를 체크한다. → Interrupt 들어온 게 없으면 다음 Instruction 실행(반복)
- 각각 인터럽트마다 어떤 일을 처리해야하는지 정의되어 있는 코드(처리하는 커널 함수) → Interrupt 처리 루틴(= Interrupt Service Routine, 인터럽트 핸들러)
- 어떤 함수(처리 루틴 주소)를 처리하러 가야하는지 표시해주는 것(일종의 테이블) → 인터럽트 벡터
- **컴퓨터 시스템에 존재하는 각 자원들의 현 상황을 파악할 수 있는 방식**
    1. Polling
        
        **CPU가 일정한 시간 간격을 두고 각 자원들의 상태를 주기적으로 확인하는 방식**
        
        자신의 상태를 적어놓을 수 있는 곳에 저장시키고 CPU는 폴링 때 그것을 읽어보는 방식
        
        - 폴링의 간격을 적절히 정해야 한다는 문제
        - 각 자원들이 직전 폴링 이후 변화된 자신의 상태를 다음번 폴링 때까지 알릴 수 없음
        - 아무 일이 없었는데도 CPU는 폴링에 일정량의 시간을 들여야 한다는 부담
        
        **▶️  자원들을 시간 간격에 맞춰서 일일이 확인 → 비효율적**
        
    2. Interrupt
        
        각 자원들이 능동적으로 자신의 상태변화를 CPU에게 알리는 방식
        
- **Interrupt는 언제 처리될까?**
    - 하드웨어 인터럽트 : 현재 진행 중인 명령어 실행을 마친 후 처리
    - 소프트웨어 인터럽트(Exception) : 처리 중인 명령어에 의해 발생되기 때문에 바로 프로그램의 종료를 가져옴
    - 소프트웨어 인터럽트(System Call) : 입출력이 완료되어야 실행 중인 명령어가 완료
- **Interrupt는 어떻게 처리될까?**
    1. 장치가 인터럽트 신호를 CPU에게 보냄
    2. CPU가 명령어를 실행중이었다면 먼저 이 명령어의 실행을 완료시키고 인터럽트 신호 확인
    3. 현재 실행 중이던 프로그램이 인터럽트 처리 후 다시 실행될 때를 위해 현 상태의 정보(PSW, PC 레지스터의 값 등)를 시스템 스택(제어 스택)에 저장(그 당시 내용 저장 → 복구 → 이어나감)
        - 문맥 교환(Context Switching)
            
            현재까지 하던 일에서 잠시 다른 일을 해야 할 때, 작업대(CPU)가 같은 곳이어야 한다면 현재까지의 모양이나 내용(상태 정보를 포함한 처리기 레지스터들의 값)을 그대로 가까운 어딘가에 보관했다가 다시 보관되었던 상태대로 일을 이어나가야 한다.
            
            - 문맥은 프로세스 상태 블록(Process Control Block)의 전부 또는 일부분이라고 보면 된다.
    4. 인터럽트 처리 루틴의 시작 주소를 PC에 넣어 실행시킴
    5. CPU에 있는 레지스터들의 값을 저장한 후(훼손될 가능성이 있기에) 필요한 인터럽트 처리를 시작
    6. 인터럽트 처리가 끝나면 이전에 저장하였던 레지스터 값들을 다시 재저장한 후 PSW와 PC값들을 원래 자리에 다시 넣어주고 실행
    7. 이전에 실행 중이던 프로그램부터 계속 실행을 이어나감
- **중첩된(다중) Interrupt 처리는?**
    1. 순차적 처리
        
        인터럽트를 처리하는 동안에 발생하는 인터럽트는 현재 처리가 끝난 뒤 바로 처리해 주는 방식
        
        하나씩 처리해준다는 의미
        
        - 중첩될수록 제어 스택의 크기가 점점 증가한다.
    2. 중첩 가능 처리
        
        현재 처리 중인 인터럽트를 잠시 접어두고 또 다른 인터럽트로 실행을 옮길 수 있도록 하는 방식
        
    
    ▶️  ***인터럽트의 중요도에 따라서 우선순위가 더 높은 경우에는 중첩, 그렇지 않으면 순차적으로 구현하는 방식도 있음***
    

<br/>

✅ ***현대의 운영체제는 인터럽트에 의해 구동됨 → Interrupt가 들어올 때만 CPU가 OS에게 넘어감***

✅  ***CPU가 Interrupt를 많이 당한다 == 효율적이지 못하게 동작***

✅  ***DMA(Direct Memory Access) Controller를 두자!***



- 중간에 I/O device에 작업이 들어왔을 때 CPU에게 Interrupt를 걸어서 CPU가 I/O device에 있는 내용을 copy하게 하는게 오버헤드가 크다!
- CPU는 계속 자기일을 하고 있고 중간중간 buffer 들어오는 내용은 작업이 끝났으면 DMA가 직접 buffer에 있는 내용을 복사하는 일을 해준다. 그 작업을 다 하고 나서 CPU에게 Interrupt를 한 번만 걸어서 CPU에게 보고. 중간에 Interrupt를 당하는 빈도가 줄어서 효율적으로 사용할 수 있음
    - **빠른 입출력 장치(인터럽트를 빈번히 거는 장치)**를 메모리에 가까운 속도로 처리하기 위해서 사용
    - CPU의 중재없이 device controller가 device의 buffer storage의 내용을 메모리에 block단위로 직접 전송 → block 단위로 interrupt 발생
- CPU, DMA가 동시에 같은 메모리 영역을 접근할 수 있기 때문에 **memory controller**가 이를 중재하는 역할을 함. 누가 먼저 쓰게 할 지 정리하는 역할.


<br/>

## **동기식 입출력(synchronous I/O)**

: I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감

- I/O 장치까지 가서 직접 확인하고 읽어와서 그거를 보고 작업(synchronous read)
- I/O 장치에 쓰는 걸 눈으로 확인하고 나서 그 다음일을 실행(synchronous write)
- I/O 요청 → device driver → 실제 I/O 장치에서 작업 진행 → 작업물 도착, 인터럽트 발생(device controller) → 다음 작업 실행
- CPU가 낭비된다 → CPU를 가지고서 기다리고 있기 때문에
- 구현 방법
    1. 기다리는 동안 CPU를 낭비, I/O도 매시점 하나만 일어난다.(낭비 and 낭비)
    2. I/O 요청 한 뒤에 다른 프로세스에게 CPU를 넘겨줌 → 얘도 I/O 요청 → CPU를 계속 넘겨줌 → 끝나는 I/O들이 Interrupt
        - CPU, I/O 장치 모두 일을 하게 된다.

## **비동기식 입출력(asynchronous I/O)**

: I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감

- I/O 요청 → 바로 CPU 제어권을 얻어서 다른 작업 진행 → 인터럽트 발생(device controller) → 작업 진행
    - I/O와 무관한 일을 계속 실행한다.
- write의 경우에는 비동기식 입출력이 자연스럽다. → 정말 잘 써져있는지 확인할 때에는 Synchronous write 진행

✅  ***두 경우 모두 I/O 완료는 Interrupt로 알려줌***

<br/>

<img width="943" alt="스크린샷 2022-02-21 오전 8 54 05" src="https://user-images.githubusercontent.com/55099365/154937645-6770088d-d0c2-4ae2-9661-56bd824f0da4.png">

**CPU에서 실행할 수 있는 일반적인 Instruction(왼쪽 그림)**

- Memory Instruction Memory 따로, I/O를 수행하는 Special Instruction 따로
- I/O device도 주소가 있어서 특정 주소 I/O device에 접근 가능

**Memory Mapped I/O : 메모리 주소에 연장 주소를 붙여서 접근을 하는 방식(오른쪽 그림)**

<br/>

## **저장장치 계층 구조**

<img width="1140" alt="스크린샷 2022-02-21 오전 8 58 04" src="https://user-images.githubusercontent.com/55099365/154937709-fa031705-04d6-428a-8db1-bb579059c625.png">


✅  ***위로 갈수록 속도가 빠르고, 용량이 적고, 휘발성 매체다.(데이터가 위에 있을수록 시스템의 성능 좋아짐)***

CPU에서 직접 접근해서 처리하는 영역 : **Primary(Executable)**

- bit 단위로 접근 가능함 → DRAM
- 속도 차이를 완충하기 위해서 Cache Memory, Register가 필요, 하지만 용량이 작아서 당장 필요한 것만 밑에서 위로 올려서 사용 : **Caching**
    - ***재사용을 위해서 필요***
- 최근에는 주기억 장치(Main Memory)와 Magnetic Disk 사이에 전자디스크(SSD)영역이 추가됨.
    - **SSD, HDD**
        
        SSD와 하드디스크의 가장 큰 차이는 저장 방식의 차이입니다. SSD는 플래시 메모리를, 하드 디스크는 마그네틱 판을 이용합니다. SSD는 하드디스크와 달리 물리적으로 회전하는 디스크, 축, 스프링, 기어, 베이링 등 물리적 손상을 불러올 수 있는 부품이 없습니다. SSD는 하드디스크 보다 빠른 속도를 지원하며, 저전력, 높은 내구성, 저소음 등의 장점을 가집니다.
        
        [https://kr.transcend-info.com/Support/FAQ-462](https://kr.transcend-info.com/Support/FAQ-462)
        

CPU에서 직접 접근해서 처리 못하는 영역 : **Secondary**

- Sector 단위로 접근하기 때문에 직접 접근해서 처리 불가

▶️  **Data가 계층 사이로 이동하는 것도 I/O인데, I/O하는데 걸리는 시간보다 저장 장치 계층 구성이 시간적으로 절약되고 효율적**

## **프로그램의 실행(메모리 load)**

<img width="1123" alt="스크린샷 2022-02-21 오전 9 07 10" src="https://user-images.githubusercontent.com/55099365/154937764-5ae8f6a4-67fb-4ff0-83de-f1978afc2260.png">


File System에 파일 형태로 저장이 되어 있다가 실행을 시키면 메모리로 올라가서 프로세스가 된다.

→ 중간에 거치는 것이 **Virtual Memory**

- 메모리 주소 공간이 만들어지게 된다. → 그 프로그램만의 **독자적인 주소 공간**(0번지부터 시작하는 독자적 주소 공간)
- 코드, 데이터, 스택 영역으로 구성
    - 코드 : CPU에서 실행할 기계어 코드
    - 데이터 : 전역 변수, 프로그램이 사용하는 자료구조
    - 스택 : 함수를 호출, 리턴할 때 데이터를 쌓을 때 사용하는 용도
- 커널이 아닌 주소 공간은 프로그램을 끄면 사라지게 된다.
- **주소 공간은 메모리에 다 올리지 않는다 → 메모리 낭비**
    - 당장 필요한 부분에 해당하는 코드만 올려두고 그렇지 않은 부분은 올리지 않는다.
        - 물리적인 메모리 : 필요한 부분 / Disk Swap Area : 그렇지 않은 부분
    - 사용을 하지 않으면 메모리에서 쫓아냄.
- 가상 메모리와 물리적 메모리에서의 주소 번지가 다르다. → **주소 변환**
    - 주소 변환 계층에서 진행

**▶️  File System 하드디스크 : 컴퓨터를 꺼도 사라지지 않음(비휘발성)**

**▶️  Swap area 하드디스크 : 메모리의 연장 공간을 사용하는 휘발성의 공간**

## **커널 주소 공간의 내용**

커널도 하나의 프로그램이기 때문에 code, data, stack으로 구성

- Code
    
    자원 관리를 위한 코드, 사용자에게 편리한 인터페이스를 제공하기 위한 코드
    
    인터럽트 처리 코드(함수 형태로 구현), System Call
    
- Data
    
    운영체제가 사용하는 여러 자료구조 정의
    
    하드웨어 관리 통제를 위한 자료구조를 만들어서 관리
    
    프로세서의 독자적인 주소 공간을 관리하기 위한 자료 구조 필요 → **PCB(Process Control Block)**
    
    - 시스템안에 프로그램이 돌아가면 그 프로그램을 관리하기 위한 자료구조가 OS 커널에 하나씩 만들어지는데 그게 PCB
- Stack
    
    함수 구조로 코드가 구성되어 있기 때문에 함수를 호출하거나 리턴할 때 Stack 필요
    
    사용자 프로그램마다 커널 스택을 따로 두고 있음
    

## **사용자 프로그램이 사용하는 함수**

모든 프로그램은 함수 구조로 짜여져 있다.

- 함수
    1. 사용자 정의 함수
        
        자신의 프로그램에서 정의한 함수
        
        내가 직접 작성한 함수
        
    2. 라이브러리 함수
        
        해당 기능을 구현해둔걸 가져다가 쓰는 것
        
        자신의 프로그램 안에 포함이 되어 있다.
        
    3. 커널 함수
        
        운영체제 안에서 정의된 함수
        
        프로그램 안에서 가져다가 사용 가능(System Call) → 커널 함수 안에 들어가 있음
