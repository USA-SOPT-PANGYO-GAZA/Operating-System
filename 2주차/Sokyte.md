운체를 설명하기 앞서 하드웨어적으로 어떻게 돌아가는지에 관련 
 

## 컴퓨터 시스템 구조

🦾 **Computer**

**CPU**
- 메모리에서 instruction을 읽고 실행 .. 의 반복 
- interrupt line : cpu는 항상 메모리에 있는 instruction을 실행 → 다른 곳의 요청 및 상황을 알려주기 위해서 존재 
- mode bit : 현재 실행하고 있는 프로그램이 OS인지, 사용자 프로그램인지 구분 
- register : 소규모 데이터 기억 장치 

**Memory**
- CPU의 작업 공간

🖱️ **I/O device
(Input-Output)**
- 각각 별개의 device
- device controller : 각 device를 전담하는 작은 CPU
- local buffer : device controller의 작업 공간



✔️ **만약 사용자 프로그램이 무한 루프 프로그램이라면? (I/O를 하지 않는)**

→ cpu가 다른 프로그램에 넘어가지 못해, `time sharing` 이 구현이 안되나?

→ 그래서 timer라는 하드웨어가 있음 : 특정 프로그램이 cpu를 독점하지 못하도록 

→ 컴퓨터 실행 시, OS가 cpu를 갖고 있다가 사용자 프로그램이 실행되면 해당 프로그램으로 cpu를 넘겨줌, 이 때 그냥 넘겨 주는 것이 아니라 timer에 일정 값을 세팅한 뒤에 넘겨주게 됨 

→ 독점적으로 사용하는 것이 아니라, timer에 할당 된 시간만 cpu를 사용할 수 있음 

→ 사용자 프로그램이 cpu를 사용하다가 할당 된 시간이 되면 timer가 `interrupt` 를 걸고 이를 cpu가 instruction 실행 🔁 interrupt line 확인 중 알게 되어 하던 일을 멈추고 cpu의 제어권이 사용자 프로그램에서 운영체제로 `자동으로` 넘어가게 됨 

→ 다음 프로그램으로 cpu를 넘겨줌 (위의 과정처럼 timer에 일정 시간을 할당한 다음) 

✔️ **사용자 프로그램은 I/O device에 접근할 수 없다, 만약 사용자 프로그램에서 해당 디바이스로의 접근이 필요하다면?** 

→ 사용자 프로그램이 자체적으로 cpu를 반납하고 운영체제가 이를 확인해서 해당 하는 I/O Controller한테 작업을 시킴

→ 운영체제는 다른 프로그램에게 cpu를 넘김 

→ 해당 I/O controller가 요청한 작업이 끝나면, interrupt를 걸음

→ 운영체제가 이를 확인한 뒤, I/O 작업의 값을 해당 프로그램의 메모리 공간에 카피 

→ 일단 작업 중인 프로그램에게 cpu를 줌

→ 해당 프로그램의 차례가 되었을 때 작업 재개 

### Mode Bit

- 사용자  프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요
- Mode Bit을 통해 하드웨어적으로 두가지 모드의 operation 지원
    - 1 = 사용자 모드 : 사용자 프로그램 수행
    - 0 = 모니터 모드 : OS 코드 수행 (모니터 모드 = 커널 모드 = 시스템 모드)
    - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 **특권 명령**으로 규정
    - Interrupt 또는 Exception 발생시 하드웨어가 mode bit을 0으로 바꿈
    - 사용자 프로그램에게 CPU를 넘기기 위해 mode bit을 1로 세팅

### Timer

- 특정 프로그램이 CPU를 독점하는 것을 막기 위해 필요
    - 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 interrupt를 발생
    - 타이머는 매 clock 틱 마다 1씩 감소
    - 타이머 값이 0이 되면 타이머 interrupt 발생
    - cpu를 특정 프로그램이 독점하는 것으로부터 보호
- 타이머는 timer sharing을 구현하기 위해 널리 이용
- 타이머는 현재 시간을 계산하기 위해서도 사용

### Device Controller

- 용어 정리
    
    Device Driver (=장치 구동기) : OS 코드 중 각 장치 별 처리 루틴 → software
    Device Controller (=장치 제어기) : 각 장치를 통제하는 일종의 작은 CPU → hardware  
    
- I/O device controller
    - 해당 I/O 장치 유형을 관리하는 일종의 작은 CPU
    - 제어 정보를 위해 control register, status register를 가짐
    - local buffer를 가짐 (일종의 data register)
- I/O는 실제 device와 local buffer 사이에서 일어남
- Device controller는 I/O가 끝났을 경우 interrupt로 cpu에 그 사실을 알림

### I/O의 수행

모든 입출력 명령은 특권 명령

사용자 프로그램은 어떻게 I/O를 하는가?

1. 사용자 프로그램은 운영체제에게 I/O를 요청
2. trap을 사용해 인터럽트 벡터의 특정 위치로 이동
3. 제어권이 인터럽트 벡트가 가리키는 인터럽트 서비스 루틴으로 이동
4. 올바른 I/O 요청인지 확인 후, I/O 수행
5. I/O 완료 시 제어권을 시스템 콜 다음 명령으로 옮김 

### Interrupt

- 인터럽트 관련 용어
    
    인터럽트 벡터 : 해당 인터럽트의 처리 루틴 주소를 갖고 있음
    
    인터럽트 처리 루틴 (인터럽트 핸들러): 해당 인터럽트를 처리하는 커널 함수 
    

인터럽트 당한 시점의 레지스터와 program counter를 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.

- Interrupt : 하드웨어 인터럽트
    - 하드웨어가 발생기킨 인터럽트
- Trap : 소프트웨어 인터럽트
    - Exception : 프로그램이 오류를 범한 경우
    - System Call : 프로그램이 커널 함수를 호출하는 경우 (사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것)

#

📌 간단하게 요약

CPU : 일꾼, 프로그램 카운터라는 cpu안의 레지스터가 가리키고 있는 메모리 주소에서 instruction을 읽어서 실행 

instruction을 실행하고 나서 다음 instruction을 실행하기 전에, interrupt line을 확인해서 들어온 인터럽트가 있는지 → 만약 있다면, 다음으로 가는 것이 아니라, 하던 일을 잠시 멈추고 cpu 제어권을 운영체제에게 넘김 → interrupt 마다 분기처리가 되어 있어, line 별로 인터럽트 벡터가 있음 (해당 인터럽트에 대해서 무엇을 실행해야 하는지, 번호-주소의 쌍을 갖고 있음) → 해당 인터럽트를 처리하는 커널 함수 실행 

mode bit에 따라서 0,1인지에 따라서 실행할 수 있는 instruction의 제한이 있음 
0이라면 모든 instruction 실행 가능, 1이라면 한정 실행 - 사용자 프로그램을 100% 신뢰할 수 없으므로
→ 만약, 사용자 프로그램에서 운영체제의 함수에 접근하고 싶다면?
: 시스템 콜 - 운영체제의 함수를 사용자 프로그램이 요청, 바로 접근한 것은 불가능하므로, 의도적으로 interrupt line을 세팅 후 운영체제에게 대신 해줄 것을 요청 

인터럽트
하드웨어가 발생시키는 인터럽트 : 하드웨어 인터럽트 (일반적인)
소프트웨어가(프로그램이) 발생시키는 인터럽트 : 트랩 
1. 사용자 프로그램이 필요에 의해서 운영체제에게 서비스를 해달라고 요청하는 - 시스템 콜
2. 사용자 프로그램이 오류에 의해서 발생 (A라는 프로그램이 이상한 작업을 하려고 했으므로 interrupt line이 자동으로 설정 → cpu가 프로그램에서 운영체제로 넘어감) - exception 발생 .. 강제 종료 등으로 대응
#

### 동기식 입출력과 비동기식 입출력

**동기식 입출력 (syschronous I/O)**

I/O 요청 후 입출력 작업이 **완료된 후에** 제어가 사용자 프로그램으로 넘어감 

ex) I/O 디바이스까지 간 뒤에 값을 읽은 뒤에 작업을 한 것 : syschronous read 

- 구현 방법 1 : I/O가 끝날 때까지 기다리는 것
    1. 기다리는 동안 cpu를 낭비
    2. 매시점의 하나의 I/O만 실행할 수 있음 
    
    → cpu, I/O 모두 낭비 
    
- 구현 방법 2 : I/O 요청 후, 해당 작업이 아닌 **다른** 프로세서에게 넘겨줌
    1. I/O가 완료될 때까지 해당 프로그램에게서 cpu를 빼앗을 수 있음
    2. I/O 처리를 기다리는 줄에 해당 프로그램을 줄 세움
    3. 다른 프로그램에게 cpu를 줌
    
    → cpu, I/O 모두 사용할 수 있음 
    

**비동기식 입출력 (asynchronous I/O)** 

I/O가 시작된 후 입출력 작업이 끝나기를 **기다리지 않고** 제어가 사용자 프로그램으로 넘어감 

→ 두 작업 모두 인터럽트를 통해서 작업이 완료됨을 알림 

두가지 입출력 방식의 차이점?

ex) 디스크에서 데이터를 읽어오는 상황 

- 프로그램에서 디스크의 데이터를 읽어오도록 요청한 후 값이 넘어오면, 그 때 작업이 이어지도록 진행 (I/O 요청 이후, 그 결과가 돌아올 경우에 그 값을 보고 그 다음 작업을 진행)
- I/O 요청과 상관 없이 할 수 있는 작업이 있다면, I/O 요청을 하고 해당 작업을 하도록 진행, 이후 결과값이 돌아오면 그 때 그 값을 통해 할 수 있는 작업을 진행

### DMA (= Direct Memory Access Controller)

버퍼의 특정 크기 이상이 쌓이면, DMA가 메모리로 카피를 하고 어느정도 쌓이면 그 때 interrupt 를 한번 걸도록 (→ cpu가 인터럽트를 당하는 일이 줄어들게 되어 보다 효율적으로 사용할 수 있음) 

- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
- CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송
- 바이트 단위가 아니라 block 단위로 인터럽트를 발생

### 서로 다른 입출력 명령어

I/O를 수행할 수 있는 방법이 서로 다른 두가지 존재

cpu의 instruction에는 메모리만 접근할 수 있는 instruction이 있고, I/O 디바이스에 접근할 수 있는 instruction이 있음 

→ 메모리 주소가 있듯 디바이스도 주소가 있어, 특정 주소를 통해서 디바이스에 접근할 수 있음 (= 일반적인 형태)


I/O 디바이스에 메모리 주소를 매겨서 메모리 접근하는 instruction을 통해 디바이스에 접근할 수 있음 (= `**Memory Mapped I/O**`라고 부름)

### 저장 장치 계층 구조

(Primary, Executable)

Register

Cache Memory

속도 차이를 완충하기 위해서 캐시 메모리를 사용, 메인 메모리보다 용량이 작기 때문에 모든 데이터를 담지 못하고 당장 필요한 데이터만 담고 있음 (밑에서 위로 올려서 사용)

→ 이를 caching이라고 함, `재사용`을 목적으로 함 (한번 읽어놓으면, 바로 접근할 수 있으므로) 

→ 새로운 데이터가 들어오면, 기존의 데이터를 쫓아내는데 해당 부분의 우선순위도 있음 

Main Memory (DRam으로 구성된)

---

(Secondary)

Magnetic Disk

Opical Disk

Magnetic 

→ 위로 갈수록 `속도`는 빠르고, `가격`은 비싸고 `용량`은 적다

→ Primary: 휘발성, CPU가 직접 접근이 가능한 경우 (= 바이트 단위로 접근이 가능한 매체)  

→ Secondary: 비휘발성, CPU가 직접 접근이 불가한 경우 

## 프로그램의 실행 (메모리 load)

프로그램이 어떻게 컴퓨터에서 실행이 되는가

프로그램이라는 것은 실행 파일 형태로 하드 디스크에 저장, 실행 시키게 되면 메모리에 올라가서 프로세스가 되어 실행 (물리적인 메모리로 바로 올라가는 것이 아니라, 한단계를 거치게 됨 → virtual memory, 가상메모리를 거치게 됨)

프로그램이 실행이 되면 해당 프로그램만의 독자적인 주소 공간이 생김 (→ code : 기계어 코드, data : 전역 변수, stack : 코드가 함수 구조로 되어 있으므로 데이터를 쌓았다가 꺼내가는 용도 .. 의 영역으로 나뉘어서 생기게 됨) 

실제로 필요한 경우 물리적인 메모리 공간에 들어가고, 사용할 경우가 아니라면 swap 공간으로 들어가게 됨 

### 커널 주소 공간의 내용

🔡 **code (커널 코드)**
- 시스템 콜, 인터럽트 처리 코드 
- 자원 관리를 위한 코드
- 편리한 서비스 제공을 위한 코드

📰 **data**
운영체제가 사용하는 여러 자료구조
하드웨어를 직접 관리 및 통제 → 각 하드웨어마다 자료구조를 만들어서 통제 
프로그램을 관리하기 위한 자료 구조 (= PCB)

🦾 **stack**
운영체제도 함수구조로 되어 있으므로 함수를 호출하거나 리턴할 때 stack 영역을 사용해야 함 (= 커널 스택이 필요)
운영체제의 코드는 요청에 따라서 불러서 사용할 수 있음 (어떤 사용자 프로그램이 커널 코드를 실행 중인가 .. 를 파악 .. 각 따로 관리)


### 사용자 프로그램이 사용하는 함수

모든 프로그램이 함수구조로 작성되어 있음 

**함수**

- 사용자 정의 함수 : 자신의 프로그램에서 정의한 함수
- 라이브러리 함수 : 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수, 자신의 프로그램의 실행 파일에 **포함되어 있음**
    
    → 함수 호출을 하더라도 프로그램 내에서 jump 
    
    ---
    
- 커널 함수 : 운영체제 안에서 정의된 함수, 프로그램 안에 들어있는 함수가 아니라, 커널 함수의 호출로 실행 (= 시스템 콜)
    
    → 함수 호출 시, 다른 영역으로의 jump이므로 불가 → 시스템 콜을 통해서 interrupt line을 세팅해서 cpu 제어권을 넘긴 후 커널 함 수 실행 
    

### 프로그램의 실행

사용자 모드 .. 커널 모드의 반복 ..
