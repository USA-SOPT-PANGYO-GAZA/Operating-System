# 운영체제 2

<img src="2주차/img/Hayden1.png" width="650"/>

- 컴퓨터 시스템 구조
    - 내부장치 : CPU, 메모리
    - I/O 장치 : 디스크 , 키보드, 마우스, 모니터... 등등
- Memory
    - CPU의 작업공간
    - 매 순간마다 메모리에서 기계어를 읽어서 실행한다
    - CPU가 직접 접근할 수 있는 내부 기억 장치

<img src="2주차/img/Hayden2.png" width="650"/>

- Device Controller
    - device를 전담하는 작은 CPU
    - 각각의 장치를 통제하는 역할 수행
    - CPU : 메모리 = Device Controller : Local Buffer (데이터를 임시로 저장하기 위한 작업공간)
    - Device Driver : CPU가 실행하는 각 디바이스에 접근하기 위한 소프트웨어

- CPU
    - Memory와 Local Buffer에 접근 가능
    - Interrupt line: 작업을 하던 중간에 신호가 들어오면 하던 일을 멈추고 interrupt 관련될 일을 먼저 처리
    - Register: CPU 내부에 메모리보다 더 빠르면서 정보를 저장할 수 있는 공간
    - Mode bit: CPU 에서 실행되는것이 운영체제인지 사용자프로그램인지 구분한다
    - 0(커널모드) - 모든 일이든 수행가능하다
    - 1(사용자 모드) - 사용자 프로그램에서 직접 하드웨어를 접근하여 보안에 취약해질 수 있기 때문에 제한된 Instruction만 실행가능
- Timer
    - 컴퓨터를 시작하면 처음에 운영 체제가 CPU를 가지고 있다가 사용자 프로그램에게 CPU를 넘겨준다.
    - 이때, Timer에 값을 세팅하고 넘겨 주게 된다.
    - 시간이 지나서 Timer의 값이 0이 되면 타이머 Interrupt가 발생하여 다른 프로그램에게 CPU를 넘겨준다.
    - 특정 프로그램이 CPU를 독점하는 것을 막는다.
- DMA (Direct Memory Access) Controller
    - 작업 처리 속도가 매우 빠른 CPU가 인터럽트를 많이 당하면 비효율적이기 때문에 CPU 이외에 메모리 접근이 가능한 DMA 컨트롤러를 둔다.
    - DMA를 사용하게 되면 로컬 버퍼에서 메모리로 읽어오는 작업을 CPU 대신 수행해 줄 수 있다.
    - CPU와 DMA중 메모리에 먼저 접근하게 만들지 Memory Controller가 교통 정리하는 역할을 한다.
    
- 시스템 콜 : 사용자 프로그램이 운영 체제의 서비스를 받기 위해 커널 함수를 호출하는 것
- 인터럽트 : ******CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외 상황이 발생하여 처리가 필요한 경우에 CPU에게 알리는 일종의 이벤트
- 하드웨어 인터럽트는 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅
- 소프트웨어 인터럽트는 소프트웨어가 CPU의 인터럽트 라인을 세팅
- 
<img src="2주차/img/Hayden3.png" width="650"/>

- 동기식 입출력: 입출력 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어가는 것

**[구현 방법 1]**

- 입출력이 끝날 때까지 인터럽트를 기다렸다가, 끝나면 사용자 프로그램에게 CPU의 제어권을 넘긴다.
- 매 시점 하나의 입출력만 일어날 수 있다.
- CPU를 낭비한다는 문제가 있다.

**[구현 방법 2]**

- 입출력이 완료될 때까지 해당 프로그램에서 CPU의 제어권을 빼앗는다.
- 입출력 처리를 기다리는 줄에 그 프로그램을 세운다.
- 다른 프로그램에게 CPU의 제어권을 넘긴다.
- 동기식 입출력은 보통 이 방법으로 구현한다.

- 비동기식 입출력: 입출력이 시작된 후, 입출력 작업이 끝나기를 기다리지 않고 CPU 제어권을 사용자 프로그램에게 즉시 넘기는 것

<img src="2주차/img/Hayden4.png" width="650"/>

1. 메모리 접근하는 기계어, I/O 접근하는 기계어가 따로 있는 방식
2. 메모리 접근하는 기계어로 I/O까지 접근하는 방식다만 메모리 주소가 I/O 장치까지 연장해서 메겨지도록 해둠

<img src="2주차/img/Hayden5.png" width="650"/>

- **Primary** CPU에서 직접 접근 가능 / 빠름 / 높은 비용 / 휘발성
- **Secondary** I/O를 통해서 접근 가능 / 느림 / 낮은 비용 / 비휘발성
- Caching: 더 빠른 스토리지 시스템에 정보 복사해두고 씀(**재사용성**)

**프로그램의 실행(메모리 load)**

<img src="2주차/img/Hayden6.png" width="650"/>

- 실행파일의 가상 메모리 중에서 즉시 필요한 것들을 실제 메모리에 올림
- 실제 메모리가 꽉찬 상태라면 스왑 메모리에 배분
- 가상 메모리는 `stack`, `data`, `code`로 구성됨
- `code`는 `address translation`을 통해 주소값이 번역되어 전달됨

**사용자 프로그램이 사용하는 함수**

- 사용자 정의 함수: 자신의 프로그램에서 정의한 함수
- 라이브러리 함수: 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수, 자신의 프로그램의 실행 파일에 포함되어 있음
- 커널 함수: 운영체제 프로그램의 함수 (커널 함수의 호출 = 시스템 콜)

**프로그램의 실행**

프로세스 A가 CPU에서 실행되고 있다고 하면, 이는 **자신의 주소 공간에 정의된 코드를 실행하는 것(**사용자 모드에서의 실행 상태**)**과 커널의 **시스템 콜 함수를 실행하는 것(**커널 모드에서의 실행 상태**)**으로 나누어 볼 수 있다.
