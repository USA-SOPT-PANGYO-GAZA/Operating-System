## **운영체제(Operating System, OS)**

- 컴퓨터 하드웨어 바로 위에 설치되는 소프트웨어 계층
- 사용자 및 다른 모든 소프트웨어와 하드웨어를 **연결**하는 소프트웨어 계층
- 모든 컴퓨터 시스템의 필수적인 부분
- 프로그램을 전체적으로 관리하는 통치자

▶️  (컴퓨터 하드웨어 + 운영체제) == 하나의 컴퓨터 시스템 

▶️  **사용자는 컴퓨터 하드웨어를 건드리지 않으면서 운영체제하고만 인터페이스해서 쉽게 컴퓨터를 사용 가능** 

▶️  다른 소프트웨어들도 하드웨어와 직접 접하기보다는 운영체제 관리를 받으면서 실행이 됨 

- ✅  **좁은 의미의 운영체제(커널)**
    - 운영체제의 핵심적인 부분 : **커널**
    - 커널 - 컴퓨터 전원을 켜서 부팅이 일어난 이후로 항상 메모리에 상주하는 부분
    - **왜 메모리에 상주할까?**
        
        커널 - 각종 기능들 중 사용자와 실행 프로그램을 위해 매우 빈번하게 사용되는 부분
        
        ex. IO.SYS, MSDOS.SYS, COMMAND.COM ... (MS-DOS)
        
        빈번하게 사용되어야 하는 부분이 디스크에 있게 되면 디스크에서 메모리로 올릴 때 많은 시간이 요구되게 되면서 시스템의 성능이 떨어지게 된다.
        
        - **전체를 커널로 만들면 되지 않을까?**
            
            메모리의 용량은 한정되기에 운영체제가 대부분의 공간을 차지하게 되면 사용자 프로그램이 올라올 공간이 없다.
            
            **▶️  사용자 프로그램들이 효과적으로 실행 불가**
            
        
    - **근래의 커널**
        
        좀 더 빠른 실행이 요구되거나 높은 수준의 보호가 필요한 프로그램들은 아예 Micro-programming하여 ROM이나 RLA와 같은 칩 형태로 만들어 놓기도 한다. 
        
        ▶️  이걸 펌웨어(생긴건 하드웨어, 내부적으로는 프로그램인 형태)라 한다.
        
- **넓은 의미의 운영체제**
    - 커널 + 여러가지 주변 시스템을 다루는 유틸리티(독립적인 프로그램)
        
        ex. WindowOS : Window Kernel + 부가적인 프로그램 설치(파일 복사...)
  
<br/>

## 운영체제의 목표

- 컴퓨터 시스템을 편리하게 사용할 수 있는 환경 제공(User Interface)
    - 어떻게 하드웨어와의 인터페이스 → 하드웨어 다루는 부분 대행
    - 어떻게 사용자, 각종 소프트웨어와의 인터페이스 
    → 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상 제공

- ✅  **컴퓨터 시스템의 자원을 효율적으로 관리(자원 관리자 Resource Management)**
    - **하드웨어** 자원 : CPU(프로세서, 중앙 처리 장치), 메모리(기억장치), 각종 입출력 장치(I/O장치), 하드디스크(보조 기억 장치) 등
    - **소프트웨어** 자원 : 프로세스, 파일, 메시지 등
    - 프로세서, 기억장치, 입출력 장치 등의 효율적 관리
    - 사용자 및 운영체제 자신을 보호
    - **어떻게 해야 한정된 CPU, 메모리를 가지고 가장 좋은 성능을 뽑아낼 수 있는가**
    - **“여러 프로그램들이 공유해서 사용하는가, 분할해서 사용하는가”, 운영체제가 관리**
- 형평성 관리
    - 특정 프로그램, 특정 사용자가 너무 차별을 받으면 안됨
- ***CPU***
    - 여러 프로그램이 동시에 실행되면 아주 짧은 시간 간격으로 CPU를 번갈아 사용
    - 컴퓨터 안에서 가장 빠른 자원(10-100ms)
    - 사용자에게 프로그램 혼자 실행을 하는 것마냥 느끼게 해준다.
    
    ***✅  운영체제가 CPU 관리***
    
- ***Memory***
    - 하나의 메모리가 통으로 주어져있는데 여러 프로그램이 동시에 실행되어야 하기 때문에 메모리를 쪼개서 프로그램들이 조금씩 메모리에 올라가게 된다.
    - 어떤 프로그램한테 얼만큼의 메모리를 할당해야 하는가 문제 발생
    
    ***✅  운영체제가 메모리 관리***
    

⏩  컴퓨터 시스템안에 있는 하드웨어 자원들 == 이미 주어져 있는 자원

- CPU가 초당 명령 몇개를 처리할 수 있는지, Memory가 몇GB인지
- **그 주어진 자원을 사용해서 최대한의 성능을 내도록 하는 것이 운영체제의 목적 → 자원 효율적 관리**

<br/>

## **운영 체제의 분류**

- 동시 작업 가능 여부
    - 단일 작업(single tasking) → 과거의 운영체제
        
        한 번에 **하나의 작업**만 처리
        
        ex. MS-DOS, 기능이 하나밖에 없고 그 기능에 충실한 특수 목적 기계를 위한 운영체제
        
    - ✅  **다중 작업(multi tasking)** → 현대의 운영체제
        
        동시에 **두 개 이상의 작업** 처리
        
        ex. UNIX, MS Windows 등
        

- 사용자의 수
    
    **컴퓨터 한 대를 여러 사용자가 동시에 접속해서 쓸 수 있는지로 분류**
    
    - 단일 사용자(single user)
        
        ex. MS-DOS, MS Windows
        
    - ✅  **다중 사용자(multi user)**
        
        각 사용자에 대한 파일, 메모리 접근을 다른 사용자가 못 보게 보안 기능 + 사용자 간의 형평성 관리 필요
        
        ex. UNIX, NT server
        

- 처리 방식
    - 일괄 처리(batch processing)
        - **작업 요청의 일정량 모아서 한꺼번에 처리**
        - 작업이 완전 종료될 때까지 기다려야 함(중간에 사용자의 개입이 허용되지 않음)
        - interactive 하지 않음
    - **✅  시분할(time sharing)** → 현대의 운영체제
        - 여러 작업을 수행할 때 컴퓨터 처리 능력을 **일정한 시간 단위로 분할**하여 사용
        - 일괄 처리 시스템에 비해 **짧은 응답 시간**을 가짐
        - 작은 시간 단위로 나누어서 번갈아가면서 CPU 할당
        - 각각의 사용자는 interactive한 서비스를 받기 가능
        - ▶️  **사람이 느끼기에 빠르게 해주면서 동시에 주어진 자원을 최대한 활용하는 것이 목적(정확한 시간을 지키는 것이 목적이 아님 → 사람 특화 시스템)**
            - 효과적으로 운영하기 위해선 다중 프로그래밍 시스템이 먼저 필요
            - **다중 프로그래밍 시스템이 필요한 이유**
                
                시간을 나누기 위해서는 받은 프로그램들이 같이 메모리에 올라와 있어야 CPU가 바로바로 다음 프로그램으로 넘어갈 수 있다.
                
                시분할 시스템이 성공하기 위해서는 다중프로그램이 전제되어야 한다.
                
        
        ex. 일반 범용 컴퓨터(Linux, Windows, iOS, Android)
        
    - 실시간(Realtime OS)
        - **정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장**되어야 하는 실시간 시스템을 위한 OS
        - 스마트폰같은 장비에서 실시간성을 필요로 하는 응용 프로그램들이 늘어나면서 OS에서 해당 애플리케이션을 어떻게 지원해줘야 할 지 중요한 이슈가 되고 있음
        → 실시간성을 지켜주도록 범용 운영체제가 어떻게 하면 되겠는가
        - **Hard realtime system(경성 실시간 시스템)**
            
            ex. 특수한 목적을 가진 시스템(원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어)
            
        - **Soft realtime system(연성 실시간 시스템)**
            
            ***데드라인이 있지만 조금 어겼다고 해서 문제가 생기지 않는 시스템***
            
            ex. 영화 보기 - 영화 인코딩때문에 데드라인 타임을 어겼다고 해서 문제가 생기진 않음 
            
<br/>

## **몇 가지 용어 정리**

- Multitasking : 하나의 프로그램이 끝나기 전에 다른 프로그램이 실행 가능한 것
(= Multiprogramming)
- Multiprogramming : 메모리에 여러 프로그램이 동시에 올라가는 방식, 특히 메모리 측면을 강조
- Time Sharing : CPU의 시간을 분할하여 나누어 쓴다는 의미, 특히 CPU쪽을 강조
- Multiprocess : 여러 프로세스(실행중인 프로그램)가 동시에 실행되는 방식

**▶️  컴퓨터에서 여러 작업을 동시에 수행하는 것을 의미**

**▶️  CPU가 하나 있더라도 시간을 조금씩 나누어서 동시에 실행이 가능한 시스템**


- ✅  **Multiprocessor(다중처리기) : 하나의 컴퓨터에 CPU가 여러 개 붙어 있음을 의미**
    - Processor == CPU == 처리기
    - **여러 프로그램이 CPU에 동시에 들어가는 것이 가능(병렬적으로 프로그램을 다룸)**
    - 하드웨어적으로 위의 용어들과 다른 프로그램
   
<br/>   

## **운영 체제의 예**

**유닉스(UNIX)**

- 대형 컴퓨터를 위해서 만들어진 운영체제
- 멀티 태스킹 가능
- 높은 이식성
    - 하나의 컴퓨터에서 돌아가는 UNIX를 전혀 다른 컴퓨터에 이식하기 쉬움
- 최소한의 커널 구조
    - 너무 많은 기능을 커널에다가 집어 넣으면 운영체제가 차지하는 메모리가 증가
    - 핵심 기능만 커널에 집어넣음
- UNIX를 위해서 언어를 만들어서 사용
    - C언어(기계, 사람에게 모두 가까운 언어)
- 소스 코드 공개
    - 누구나 가져다 쓰기 좋음, 운영체제 공부하기 좋음
- 프로그램 개발에 용이
    - 일반인에게는 어려움

ex. System V, FreeBSD, SunOS, Solaris, **Linux**

- **Linux**
    - 누구나 자유롭게 사용할 수 있는 운영체제
    - 대형 컴퓨터, 여러 사용자가 서버에 접속해서 사용하는 서버를 위한 운영체제
    - 개인용 컴퓨터로 쓰기에도 좋은 특징을 가짐
    - Android - 운영체제 커널을 Linux Kernel 사용

**DOS(Disk Operating System)**

- PC 용량이 작고, 단일 프로그램만 지원 → 단일 작업용 운영체제
- 640KB까지만 지원해줌

**MS Windows**

- PC를 위해서 만들어진 운영체제
- 단일 사용자, 단일 작업을 위한 운영체제로 시작 → DOS
- 다중 작업용 GUI 기반 운영 체제
- 불안정성(초창기 MS Windows)
- 풍부한 지원 소프트웨어

<br/>

## **운영 체제의 구조**

자원들을 관리하는 것이 운영체제의 기능

- CPU
    - 어떤 프로그램한테 CPU를 할당할 것인가? **CPU 스케줄링**
        - 먼저 온 순서대로 처리 → 하나의 프로그램이 오랜 시간동안 점유하고 있다면 다른 프로그램들은 하염없이 기다려야 한다.(비효율적)
        - CPU 자체는 굉장히 빠른데, 작업들이 CPU를 얻은 다음에 놓지 않으려고 한다면 빠른 자원을 효율적으로 활용할 수 없기에 **CPU 스케줄링은 짧은 시간 간격으로 CPU를 줬다 뺐는 방식을 일반적으로 사용**
        - (이론) CPU를 가장 짧게 사용할 프로그램한테 CPU를 가장 먼저 줘야 함 → 나머지 프로그램들의 응답 시간이 짧아지면서 평균적인 성능이 좋아짐
- Memory
    - 메모리 공간은 한정되어 있는데 여러 프로그램들이 동시에 메모리에 올라가고 싶어함
    - 어떤 프로그램한테 메모리를 얼만큼 할당해야 하는가? **메모리 관리**
        - 공평하게 1/N → **사실 공평하지 않다**
        - 메모리를 분배하는 이슈에 있어서는 프로그램이 점점 많아지면 각각이 가지는 메모리 공간이 점점 작아지기 때문에 프로그램이 원활하게 실행 불가
        - **CPU에서 프로그램이 실행되려면 최소한 실행에 필요한 부분이 메모리에 올라와있어야 한다.(디스크 아무리 있어도 실행안됨) → Stored Program Concept**
    - 지나치게 프로그램이 많으면 CPU에서 프로그램을 실행하려고 할 때 해당 프로그램이 메모리에 없어서 Disk에서 읽어와야 한다.
        - 원활하게 전체 시스템 실행 불가
        - **동시에 많은 프로그램을 올려놓는 것보다는 그 정도 메모리는 받을 수 있도록 지원해주자** → **Working Set Model**
        - **Working Set Model**
            - 너무 많은 프로그램이 동시에 실행되려고 하면 일부 프로그램만 어느정도 메모리 공간을 할당해주고 나머지는 전부 Disk로 쫓아내버려서 올라가있는 프로그램만이라도 CPU에서 원활하게 실행하도록 해줌.
            - 나중에 Disk에 있는 프로그램을 실행할 때에는 Memory에 있는 프로그램을 Disk로 내려두고 해당 프로그램을 Memory로 올리는 식으로 진행.
    - **공평하게 나누는 것이 아니라 그때그때 특정 프로그램에게 몰아주면 더 원활하게 실행 가능**
    - 어떤 프로그램을 메모리에서 쫓아내야 하는가?
        - 해당 프로그램을 다시 사용하게 될 지 미래 예측을 해야 함
        - 다시 사용될 가능성이 있는지 예측 → 최근에 사용을 많이 했는지
- Disk
    - 디스크에서 파일을 어떻게 보관하는가? **파일 관리**
        - 조각조각으로 나눌지, 연속적으로 관리하는게 좋을지
    - **디스크 스케줄링**
        - 디스크를 읽거나 쓰거나하는 요청을 어떤 순서대로 처리할 것인가?
        - Head에 가까운 위치에 들어온 요청이 있다면 순서를 바꿔서 디스크 Head의 이동을 줄이는 쪽으로 해서 사용 → 디스크의 성능이 높아짐
        - **CPU 스케줄링과의 차이**
            - CPU 스케줄링 : CPU가 너무 빨라서 어떻게 관리를 해줘야 하는가
            - 디스크 스케줄링 : 디스크의 이동을 어떻게 최소화할 것인가
- I/O device
    - 입출력 장치와 컴퓨터 내부가 어떻게 정보를 주고 받게 할 것인가? **입출력 관리**
        - Interrupt에 기반해서 관리
        - Interrupt를 걸어서 입출력장치가 CPU에게 보고한다. → 다음 작업 전에 입출력 장치가 요청한 것을 확인하고 처리해줌
        - CPU가 최대한 방해받지 않고 사용하게 해줌
- **프로세스 관리(소프트웨어, 프로그램 관리)**
    - 프로세스의 생성과 삭제
    - 자원 할당 및 반환
    - 프로세스 간 협력
- 그 외
    - 보호 시스템
    - 네트워킹
    - 명령어해석기(command line interpreter)
