# 운영체제 두 번째 시간

깔끔하게 보고 싶다면: https://taekkidev.oopy.io/os/2

## *궁금증 정리

---

💭 **운영체제도 메모리에 올라가는가?**

운영체제에 대한 설명을 보면 하나의 소프트웨어라고 설명되어 있다. 그렇다면 운영체제도 하나의 프로그램이라는 이야기이다. 운영체제도 프로그램이기 때문에 메모리에 올라가 있어야 실행할 수가 있다. 프로그램 중에 필요한 부분만 호출해서 실행하게 되고 **(항상 필요한 부분만 메모리에 올린다.)**, 운영체제 중에서 메모리에 올라가 있는 핵심부분을 **커널(Kernel)** 이라고 한다.

좁은 의미의 운영체제는 커널을 일컫고, 넓은 의미의 운영체제는 커널을 포함해 시스템을 위해 제공되는 유틸리티까지 포함한다.

[참고] [https://makecodework.tistory.com/entry/운영체제-101운영체제개념-개요-및-기능](https://makecodework.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-101%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EA%B0%9C%EB%85%90-%EA%B0%9C%EC%9A%94-%EB%B0%8F-%EA%B8%B0%EB%8A%A5)

## 0. 들어가며

---

`다음은 반효경 교수님의 운영체제 강의를 바탕으로 정리된 내용입니다.`

운영체제는 컴퓨터 하드웨어 바로 위에 설치되는 **소프트웨어 계층**으로서 모든 컴퓨터 시스템의 필수적인 부분이다.

## 1. 컴퓨터 시스템 구조(Computer-System Orgranization)

---

컴퓨터 시스템은 `CPU`, `메모리`, `디스크`, `I/O 장치` 등으로 구성된다. 좀 더 자세히 설명하면 다음과 같이 이야기 할 수 있다. 현대의 일반적인 컴퓨터 시스템은 한 개 이상의 CPU와 수많은 장치 컨트롤러(device controller)로 구성되어 있다. 그리고 이것들은 구성요소들과 공유 메모리 사이에 접근을 제공하는 공통 버스(common bus)로 연결되어 있다.

![공부하기 싫어서 손으로 그린 그림](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/828d4198-64a1-4c60-844e-b4ab8ff293e3/Untitled_Artwork_2.png)

공부하기 싫어서 손으로 그린 그림

### CPU

**`설명`**

CPU의 운명은 메모리에 있는 기계어(또는 명령어)를 읽어오는 작업을 하는 것이라고 할 수 있다. 메뉴얼대로만 움직이는 아주 불쌍한 친구이다. 메모리에서 매 순간(정확히 말하자면 Clock Cycle)마다 기계어(instruction)를(을) 읽어서 실행을 시킨다.

기계어만 읽지는 않는다. 하나의 기계어 읽는 작업이 끝나면 interrupt line을 검사해서 인터럽트가 들어왔는지 검사한다. 인터럽트가 무엇인지는 밑에서 다시 살펴보겠다.

**`더 알아보기`**

**register**

- 메모리보다 더 빠르면서 정보를 저장하는 더 작은 공간이다.

**mode bit**

- CPU를 가지고 있는 것(제어권)이 운영체제인지 사용자 프로그램인지 구분해준다.
- 모드 구분
    - 1 - 사용자 모드
    - 0 - 모니터 모드 (커널 모드, 시스템 모드, OS 관련)

보안상의 이유로 mode bit이 1일 때는 제한된 기계어(instruction)만 수행 가능하다. 반대로 0일 때는 과장해서 모든 작업이 수행 가능하다. 사용자 프로그램에게 CPU를 넘겨줄 때에는 mode bit을 1로 바꾸어서 넘겨주게 된다.

**interrupt line**

- 인터럽트가 들어왔는지 체크해준다.
- 인터럽트가 들어왔다는 것은 약간 이런 느낌이다. 
(너 이제 다른 일 할 시간이야, 너 다른 프로그램 살펴봐야지)
- 인터럽트가 들어오면 CPU의 제어권이 운영체제에게 넘어간다.

### Memory

**`설명`**

CPU의 작업 공간이라고 할 수 있다.

**`더 알아보기`**

메모리에 대해서는 나중에 더 자세히 알아보도록 하자.

### I/O device(입출력 장치)

**`설명`**

신기한 점(?!)은 입출력 장치도 역시 자그마한 CPU, Memory를 가지고 있다. 정확히 말하자면 다르지만 그렇게 이해하면 될 것 같다. 각각 device controller, local buffer로 불리운다.

I/O는 실제 device와 local buffer 사이에서 일어난다. device controller는 I/O가 끝났을 경우 인터럽트로 CPU에 사실을 알린다.

**`더 알아보기`**

**device controller**

- 작은 CPU의 역할을 한다.
- 각각의 입출력 장치(I/O device)를 전담한다.
- 제어 정보를 위해 control register, status register, local buffer를 가진다.
- I/O가 끝났을 경우 인터럽트로 CPU에 사실을 알린다.
- cf) **device driver** - OS 코드 중 각 장치별 처리루틴을 의미한다. 하나의 소프트웨어이다.

**local buffer**

- 메모리의 역할을 한다.
- 입출력 장치도 각각의 작업 공간이 필요하기 때문에 local buffer라는 것이 존재한다.

**💭 Disk가 Input device, Output device 둘 다 해당된다?**

- Input device → 하드디스크 상의 데이터를 읽어서 메모리로 가져오기도 한다.
- Output device → 처리 결과를 파일 시스템에 저장한다.

### Mode bit

**`설명`**

해당 장치는 위에서 살펴보았다. 다음과 같이 이야기 할 수 있다.

- CPU를 가지고 있는 것(제어권)이 운영체제인지 사용자 프로그램인지 구분해준다.
- 모드 구분
    - 1 - 사용자 모드
    - 0 - 모니터 모드 (커널 모드, 시스템 모드, OS 관련)

보안상의 이유로 mode bit이 1일 때는 제한된 기계어(instruction)만 수행 가능하다. 반대로 0일 때는 과장해서 모든 작업이 수행 가능하다. 사용자 프로그램에게 CPU를 넘겨줄 때에는 mode bit을 1로 바꾸어서 넘겨주게 된다.

**`더 알아보기`**

그렇다면 해당 장치는 왜 존재해야 할까? 사용자 프로그램이 다른 프로그램에 간섭하거나 운영체제에 피해를 주는 것을 막기 위한 보호 장치라고 생각하면 좋을 것 같다.

### Timer

**`설명`**

만약 우리가 코드를 작성해서 무한 반복하는 프로그램을 만들었다고 생각해보자. CPU는 계속 하나의 프로그램의 작업만 처리해야할 것이다. 이렇게 하나의 사용자 프로그램이 CPU를 독점하는 것을 방지하기 위해 존재하는 것이 Timer이다.

정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킨다. 매 클럭 사이클 때마다 1씩 감소하다가 값이 0이 되면 타이머 인터럽트가 발생한다. (여기서도 역시 인터럽트가 발생한다.)

### DMA Controller

**`설명`**

원래는 CPU만 메모리에 접근하는 것이 어찌보면 당연한 것 같다. 그러나 현실상 그러기 어렵다. 만약 I/O device가 인터럽트를 너무 많이 걸면 CPU에 부담이 가고 상당히 비효율적일 수 밖에 없다. 그래서 직접 메모리에 접근할 수 있는 컨트롤러를 하나 두어 CPU의 부담을 덜어주려고 하는 것이 DMA Controller에 대한 설명이다.

DMA는 Direct Memory Access의 약자로써 DMA Controller는 직접 메모리에 접근할 수 있는 컨트롤러이다. CPU를 직접 거치지 않고, device controller가 장치의 local buffer에 있는 데이터를 카피해서 메모리에 전송한다. 전송이 완료되면 DMA Controller는 인터럽트 신호를 CPU로 보내게 된다.

요약하면 CPU는 전송의 시작과 끝만 담당하게 되는 것이다.

[https://velog.io/@suuhyeony/운영체제-Ch2.-시스템-구조와-프로그램-실행](https://velog.io/@suuhyeony/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Ch2.-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B5%AC%EC%A1%B0%EC%99%80-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89)

**`더 알아보기`**

- byte 단위가 아닌 block 단위로 인터럽트를 발생시킨다고 한다.
- 메모리에 CPU와 DMA Controller가 동시에 접근하는 상황이 생길 수도 있으므로 메모리에도 Memory Controller가 존재해 그 조절을 해준다.

## 2. 입출력(I/O)

---

- 모든 입출력 명령은 특권 명령이다.
- **사용자 프로그램의 I/O 수행 과정**
    
    이 부분에서 **시스템콜**의 개념이 등장한다.
    
    1. 시스템콜이 발생한다.
        - 사용자 프로그램이 운영체제에게 **I/O 요청**을 한다.
        - 사용자 프로그램이 의도적으로 인터럽트 라인을 세팅한다.
    2. trap(I/O 요청 시에 발생하는 소프트웨어 인터럽트를 의미)을(를) 사용해서 인터럽트 벡터(interrupt vector)의 특정 위치로 이동한다.
    3. 제어권이 인터럽트 벡터가 가리키는 인터럽트 처리 루틴(interrupt service routine)으로 이동한다.
    4. 올바른 I/O 요청인지 확인 후 수행한다.
    5. I/O 완료 시, 제어권을 시스템콜 다음 명령으로 옮긴다.

## 3. 인터럽트(Interrupt)

---

**`설명`**

<aside>
⛔ 현대의 운영체제는 인터럽트에 의해 구동된다.
</aside>

인터럽트가 발생했다고 했을 때, 그 시점에 레지스터와 PC(Program Counter)의 상태를 저장하고 CPU의 제어권을 인터럽트 처리 루틴으로 넘긴다. 간단하게 생각하면 사용자 프로그램이 동작하고 있다가 인터럽트가 발생하면 우선 CPU의 제어권이 운영체제로 넘어가는 상황이라고 생각해도 괜찮을 것 같다.

인터럽트는 일반적으로 하드웨어가 발생시킨 인터럽트를 의미한다. 소프트웨어가 발생시키는 인터럽트도 존재한다. 위에서 살짝 언급되었는데, 사용자 프로그램이 동작하다가 입출력 장치에 접근하고 싶은 경우가 생긴다. 이 때 직접 접근을 할 수 없으니 운영체제를 통해서 접근을 해야 하는데 그럴 때 인터럽트를 발생시켜야 한다. 요렇게 소프트웨어 인터럽트를 **Trap**이라고 부른다.

**`더 알아보기`**

**Trap (소프트웨어 인터럽트)**

- Exception - 프로그램이 오류를 범한 경우, 예외 상황(0으로 나눈다거나 하는 상황)
- System call - 프로그램이 커널 함수를 호출하는 경우, 운영체제에 있는 함수에 접근해야 하는 경우

**인터럽트 벡터**

- 인터럽트가 발생했을 때 어디에 있는 함수를 호출해야 하는지의 주소를 가지고 있다.
- 해당 인터럽트의 처리 루틴 주소를 가지고 있다.

**인터럽트 처리 루틴**

- 해당 인터럽트를 처리하는 커널 함수를 의미한다.
- 처리해야 할 실제 코드라고 볼 수 있다.

## 4. 시스템콜(System Call)

---

시스템 콜이란 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것을 의미한다.

**`더 자세한 설명`**

시스템 호출(System Call)은 간단하게 말해서 유저 영역(User mode)과 커널 영역(Kernel mode)간의 커뮤니케이션이 되는 개념이다. 운영 체제의 커널이 제공하는 서비스에 대해서 응 용프로그램의 요청이 들어오면 커널에 접근할 수 있도록 도와준다. 예를 들어서, 유저 영역에서 화면에 메시지를 출력하는 기능을 수행하고 싶다면 System Call Interface가 커널 영역에 그 기능을 요청하고 해당 기능이 수행된 결과를 다시 유저 영역으로 반환해준다.

## 5. 동기식 입출력과 비동기식 입출력

---

### 동기식 입출력 (Synchronous I/O)

I/O 요청 후에 작업이 완료된 후에야 제어권이 사용자 프로그램에 넘어간다. (다른 일을 수행하지 않고 기다린다, 결과를 보고 다음 작업을 수행한다.)

### **비동기식 입출력**(Asynchronous I/O)

I/O가 요청 후에 작업이 끝나기를 기다리지 않고, 제어권이 사용자 프로그램에 즉시 넘어간다.

**두 가지 방식에 가장 큰 차이는 I/O 요청 후에 그 작업을 기다리느냐 안 기다리느냐의 차이이다.**

## 6. 서로 다른 입출력 명령어

---

![System Structure & Program Execution 2 - 운영체제(반효경)강의 일부 스크린샷](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9ffcc578-e7ce-4103-a341-37a783d71cb9/스크린샷_2022-02-20_오후_11.54.23.png)

System Structure & Program Execution 2 - 운영체제(반효경)강의 일부 스크린샷

instruction에는 2가지 종류가 있다. 메모리에 접근하는 instruction과 I/O 장치에 접근하는 instruction이다. 좌측 그림처럼 일반적으로 메모리와 디바이스 주소를 따로 두는 것이 일반적이다. 우측 그림은 디바이스 주소도 메모리 주소의 연장선으로 생각해 메모리 주소를 매겨서 접근할 수도 있음을 보여준다.

- **일반적인 I/O -** I/O를 수행하는 special instruction에 의한 방식 (좌측 그림 방식)
- **Memory Mapped I/O -** (우측 그림 방식)

## 7. 저장장치 계층 구조

---

![해당 부분은 컴퓨터 구조에서 더 자세히 공부할 수 있기 때문에 대략적으로 보고 넘어간다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/65602c78-376c-4806-a962-7d3bbb2bf6dd/스크린샷_2022-02-20_오후_11.58.08.png)

해당 부분은 컴퓨터 구조에서 더 자세히 공부할 수 있기 때문에 대략적으로 보고 넘어간다.

- 상위로 올라갈수록 속도가 빠르고 비용이 비싸고 용량이 적다.
    - Speed up, Cost up, Volatility down
- Primary 저장장치와 Secondary 저장장치로 구분될 수 있다.
    - Primary - CPU가 직접 접근해서 처리 가능, 휘발성 매체
    - Secondary - CPU가 직접 접근해서 처리 불가능, 비휘발성 매체
- Caching(캐싱)
    - 빠른 저장 장치로 정보를 카피해서 올리는 작업

## 8. 프로그램의 실행 (메모리 load)

---

<aside>
⛔ 프로그램이 어떻게 컴퓨터에서 실행되는가에 대한 부분입니다.

</aside>

- 프로그램은 보통 실행파일의 형태로 하드 디스크, 파일 시스템에 파일 형태로 저장되어 있다.
- 실행 파일을 실행하게 되면 메모리에 올라가서 **프로세스**가 된다.
    - **프로세스**는 실행 가능한, 실행 중인 프로그램이라고 봐도 될 것 같다.

### **가상 메모리 (Virtual memory)**

프로그램은 보통 물리적 메모리에 바로 올라가지 않고, **중간에 거치는 단계**가 존재한다.

- 중간에 **가상 메모리(Virtual Memory)** 를 거치게 된다.
- 가상 메모리(Virtual Memory) - 각 프로그램마다 독자적으로 가지고 있는 메모리 주소 공간
    - **stack 영역 - 데이터를 쌓거나 빼가는 영역**
    - **data 영역 - 변수, 자료구조 영역**
    - **code 영역 - 기계어 코드 영역**
- 사용자 프로그램의 주소 공간은 필요한 부분만 메모리에 올려놓고, 프로그램 종료 시에는 사라지게 된다.
- 당장 필요한 것만 메모리에 올리고, 그렇지 않은 부분들은 Swap area에 내려와 있다.

### 커널 영역 (**Kernel Address Space**)

**커널 영역**의 경우 부팅을 시키면 항상 메모리에 올라가 있다. 운영체제 커널도 하나의 프로그램이다.

![스크린샷 2022-02-21 오전 12.14.31.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ab526cf-0113-4c82-a1c6-3e96a96edabb/스크린샷_2022-02-21_오전_12.14.31.png)

- **code**
    - 시스템 콜, 인터럽트 처리 코드
    - 자원 관리를 위한 코드
    - 편리한 서비스 제공을 위한 코드
- **data**
    - cpu, mem, disk 관리하기 위한 자료구조를 가지고 있다.
    - 프로세스마다 PCB(Process Control Block)가 존재한다.
- **stack**
    - 프로그램의 커널 스택
    

### 사용자 프로그램이 사용하는 함수

- **사용자 정의 함수** - 직접 작성한 함수
- **라이브러리 함수** - 가져다 쓰기만 하면 되는 함수
- **커널 함수** - 운영체제 안에서 정의된 함수, 커널 코드 안에 들어있는 함수
    - 내 프로그램 안에는 존재하지 않는다.
    - 내 프로그램이 커널 함수에 접근하려면 시스템콜이 필요하다.

### 프로그램의 실행

![스크린샷 2022-02-21 오전 12.17.15.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/edaf398f-ac18-42c6-8be4-dd8aeed5dabc/스크린샷_2022-02-21_오전_12.17.15.png)

유저 모드 - 커널 모드 - 유저 모드 - 커널 모드 ... (반복)

